<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bio-Sphere Manager デモ</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@latest/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@latest/dist/chart.umd.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    *{box-sizing:border-box;}
    body{
      margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      background:radial-gradient(circle at 20% 20%, rgba(90,162,247,0.08), transparent 40%), #060a0f;
      color:#e6edf3; line-height:1.5;
      font-size: clamp(16px, 1.6vw, 19px);
      letter-spacing:0.02em;
      overflow:hidden;
    }
    #mapStage{
      position:fixed; left:0; top:0; right:360px; bottom:0; z-index:1; overflow:hidden;
      background-color:#05080f;
      background-image:
        linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px),
        radial-gradient(circle at 10% 20%, rgba(60,120,200,0.08), transparent 42%);
      background-size: 48px 48px, 48px 48px, auto;
      pointer-events:auto;
    }
    #canvasHost{position:absolute; inset:12px 12px 12px 12px; border-radius:18px; box-shadow:0 18px 46px rgba(0,0,0,0.55); overflow:hidden; z-index:2;}
    #mapStage canvas{display:block; width:100%; height:100%;}
    .canvas-debug{position:absolute; left:12px; top:12px; padding:8px 10px; border-radius:12px; border:1px solid #30445c; background:rgba(6,10,15,0.72); color:#cfd8e3; font-size:12px; display:flex; gap:8px; align-items:center; z-index:5;}
    .canvas-debug.off{opacity:0.4;}
    .canvas-debug .stat{text-shadow:0 2px 8px rgba(0,0,0,0.6);}
    .canvas-debug .stat.is-error{color:#ff8a8a; font-weight:800;}
    .canvas-debug button{border:1px solid #30445c; background:#0e1622; color:#cfd8e3; border-radius:8px; padding:4px 8px; cursor:pointer; font-size:11px;}
    header{
      padding:16px 18px; border-bottom:1px solid #101826;
      background: linear-gradient(180deg, #0f1620, #0b0f14);
      position: sticky; top:0; z-index:12;
      box-shadow:0 12px 34px rgba(0,0,0,0.35);
    }
    header .title{font-size:22px; font-weight:800;}
    header .sub{font-size:13px; color:#9fb0c3; margin-top:6px;}

    canvas{display:block;}

    /* Widget system */
    .widget{position:fixed; z-index:10; border-radius:14px; border:1px solid #223247; background:rgba(12,18,26,0.94); box-shadow:0 12px 34px rgba(0,0,0,0.45); min-width:240px; pointer-events:auto; color:#dce6f3; touch-action:none;}
    .widget-header{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; background:linear-gradient(180deg, rgba(26,42,60,0.95), rgba(15,24,36,0.95)); border-bottom:1px solid #1f2a37; cursor:grab; user-select:none;}
    .widget.dragging .widget-header{cursor:grabbing;}
    .widget-title{font-weight:800; font-size:14px; letter-spacing:0.04em;}
    .widget-controls{display:flex; gap:6px; margin-left:auto;}
    .widget-controls button{padding:6px 8px; min-height:28px; border-radius:10px; border:1px solid #2a3a52; background:#132235; color:#dce6f3; cursor:pointer;}
    .widget-controls button:hover{background:#1c2e48;}
    .widget-body{padding:10px 12px; max-height:70vh; overflow:auto;}
    .widget.is-minimized .widget-body{display:none;}
    .widget.is-minimized{height:auto;}
    .widget.is-maximized{position:fixed; inset:6vh 6vw; width:auto; height:auto; z-index:50; box-shadow:0 16px 42px rgba(0,0,0,0.55);}
    .widget.is-maximized .widget-body{max-height:calc(88vh - 70px); overflow:auto;}
    .widget.is-maximized .widget-header{cursor:default;}

    .widget-dock{position:fixed; left:12px; bottom:12px; right:12px; display:flex; justify-content:space-between; gap:12px; z-index:11; pointer-events:none;}
    .dock-col{display:flex; gap:8px; flex-wrap:wrap; pointer-events:auto;}
    .dock-chip{border-radius:12px; padding:8px 12px; border:1px solid #2a3a52; background:#0d1420; color:#c9d6e2; cursor:pointer; box-shadow:0 8px 24px rgba(0,0,0,0.35);}

    .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #2a3a52; background:#132235; font-size:12px; color:#9fb0c3;}
    .btn{background:#132235; border:1px solid #243244; border-radius:10px; padding:10px 12px; color:#e6edf3; cursor:pointer;}
    .btn:hover{background:#1a2e46;}
    .btn.primary{background:#1b3554; border-color:#2a466b;}
    .btn.danger{background:#3a1620; border-color:#5a2430;}

    .hud-grid{display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:10px;}
    .hud-item{border:1px solid #223247; border-radius:12px; padding:8px 10px; background:rgba(17,24,38,0.9);}    
    .hud-item .label{font-size:12px; color:#9fb0c3; margin-bottom:6px; letter-spacing:0.05em;}
    .hud-item .value{font-size:20px; font-weight:800;}

    .legend-grid{display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(140px,1fr));}
    .legend-row{display:flex; align-items:center; gap:8px;}
    .legend-swatch{width:16px; height:16px; border-radius:4px; border:1px solid #d9e2f3;}

    .section{border:1px solid #223247; border-radius:12px; margin-top:12px; overflow:hidden;}
    .section summary{cursor:pointer; padding:12px 14px; font-weight:700; color:#c3d5eb; list-style:none; user-select:none; background:linear-gradient(90deg, rgba(34,50,71,0.4), rgba(34,50,71,0.1));}
    .section[open] summary{border-bottom:1px solid #223247;}
    .section summary::-webkit-details-marker{display:none;}
    .section .section-body{padding:14px; display:grid; gap:14px;}

    .floating-settings{position:fixed; right:18px; bottom:20px; z-index:25;}
    .fab{border-radius:999px; padding:12px 18px; font-weight:700; box-shadow:0 12px 32px rgba(0,0,0,0.45);}

    .backdrop{position:fixed; inset:0; background:rgba(8,12,18,0.72); display:none; align-items:center; justify-content:center; z-index:100; pointer-events:none;}
    .backdrop.active{display:flex; pointer-events:auto;}
    .modal{background:#0d1420; border:1px solid #30445c; border-radius:14px; padding:18px 20px; min-width:280px; max-width:480px; box-shadow:0 14px 40px rgba(0,0,0,0.55);}
    .modal h3{margin:0 0 10px 0; font-size:18px;}
    .modal p{margin:0 0 12px 0; color:#cdd9e5;}
    .status-badge{position:absolute; left:14px; bottom:14px; background:rgba(30,10,10,0.7); border:1px solid rgba(255,120,120,0.45); color:#ffb0b0; padding:8px 10px; border-radius:10px; font-size:13px; pointer-events:none; z-index:6; box-shadow:0 8px 20px rgba(0,0,0,0.4);}
    .hidden{display:none!important;}
  </style>
</head>
<body>
  <div id="mapStage">
    <div id="canvasHost" aria-label="シミュレーションマップ"></div>
    <div class="canvas-debug" id="canvasDebug">
      <span class="stat" id="canvasSizeStat">キャンバス: --</span>
      <span class="stat" id="canvasDprStat">DPR: --</span>
      <span class="stat" id="canvasRenderStat">最終描画: -- ms</span>
      <span class="stat" id="canvasTilesStat">タイル数: --</span>
      <button id="canvasDebugToggle" aria-pressed="true">非表示</button>
    </div>
    <div class="status-badge hidden" id="canvasStatus">キャンバス初期化を再試行中...</div>
  </div>
  <header>
    <div class="title">Bio-Sphere Manager</div>
    <div class="sub">ウィンドウ管理リフレッシュ＋生態系サンドボックス</div>
  </header>

  <div class="widget" id="hudWidget" data-widget-id="hudWidget" style="left:16px; top:96px; width:360px;">
    <div class="widget-header" data-widget-id="hudWidget">
      <div class="widget-title">状態表示</div>
      <div class="widget-controls">
        <button data-action="minimize" data-widget-id="hudWidget">—</button>
        <button data-action="maximize" data-widget-id="hudWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="hud-grid">
        <div class="hud-item"><div class="label">個体数</div><div class="value" id="hudPop">0</div></div>
        <div class="hud-item"><div class="label">季節</div><div class="value" id="hudSeason">春</div></div>
        <div class="hud-item"><div class="label">気温</div><div class="value" id="hudTemp">0℃</div></div>
        <div class="hud-item"><div class="label">降雨</div><div class="value" id="hudRain">0</div></div>
        <div class="hud-item"><div class="label">スコア</div><div class="value" id="hudScore">0</div></div>
      </div>
    </div>
  </div>

  <div class="widget" id="summaryWidget" data-widget-id="summaryWidget" style="left:400px; top:96px; width:320px;">
    <div class="widget-header" data-widget-id="summaryWidget">
      <div class="widget-title">世代サマリ</div>
      <div class="widget-controls">
        <button data-action="minimize" data-widget-id="summaryWidget">—</button>
        <button data-action="maximize" data-widget-id="summaryWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div id="presetInfo" class="help">プリセット: 温帯森林</div>
      <div id="genSummary">まだデータがありません。</div>
    </div>
  </div>

  <div class="widget" id="controlsWidget" data-widget-id="controlsWidget" style="left:16px; top:320px; width:320px;">
    <div class="widget-header" data-widget-id="controlsWidget">
      <div class="widget-title">クイック操作</div>
      <div class="widget-controls">
        <button data-action="minimize" data-widget-id="controlsWidget">—</button>
        <button data-action="maximize" data-widget-id="controlsWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
        <button class="btn primary" id="startBtn">開始</button>
        <button class="btn" id="stopBtn">停止</button>
        <button class="btn" id="stepBtn">1ステップ</button>
        <button class="btn danger" id="panicBtn">パニック</button>
      </div>
      <div class="section">
        <details open>
          <summary>オーバーレイ切替</summary>
          <div class="section-body">
            <label><input type="checkbox" id="toggleHearts" checked /> ♡を表示</label>
            <label><input type="checkbox" id="toggleFlashes" checked /> 狩りエフェクトを表示</label>
            <label><input type="checkbox" id="toggleTrails" checked /> 軌跡を表示</label>
            <label><input type="checkbox" id="toggleVectors" checked /> 速度ベクトルを表示</label>
          </div>
        </details>
      </div>
      <div class="section">
        <details open>
          <summary>カメラ</summary>
          <div class="section-body">
            <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn" id="resetView">表示リセット</button>
              <label style="display:flex; gap:6px; align-items:center; font-size:13px; color:#a9b7c6;">
                ズーム
                <input id="zoomSlider" type="range" min="0.5" max="2.5" step="0.01" value="1" />
              </label>
            </div>
          </div>
        </details>
      </div>
    </div>
  </div>

  <div class="widget" id="legendWidget" data-widget-id="legendWidget" style="right:16px; top:96px; width:300px;">
    <div class="widget-header" data-widget-id="legendWidget">
      <div class="widget-title">凡例</div>
      <div class="widget-controls">
        <button data-action="minimize" data-widget-id="legendWidget">—</button>
        <button data-action="maximize" data-widget-id="legendWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="legend-grid" id="legendList"></div>
    </div>
  </div>

  <div class="widget" id="settingsWidget" data-widget-id="settingsWidget" style="right:16px; top:320px; width:360px;">
    <div class="widget-header" data-widget-id="settingsWidget">
      <div class="widget-title">設定</div>
      <div class="widget-controls">
        <button data-action="minimize" data-widget-id="settingsWidget">—</button>
        <button data-action="maximize" data-widget-id="settingsWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="section">
        <details open>
          <summary>シミュレーション</summary>
          <div class="section-body">
            <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn" data-preset="temperate">温帯森林</button>
              <button class="btn" data-preset="savanna">サバンナ</button>
              <button class="btn" data-preset="wetland">湿地</button>
            </div>
            <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
              <label><input type="checkbox" id="modeExtinction" /> 全滅まで実行</label>
            </div>
            <div class="section" style="margin-top:8px;">
              <details open>
                <summary>行動モード（種別ごと）</summary>
                <div class="section-body" id="behaviorControls" style="display:grid; gap:8px;"></div>
              </details>
            </div>
          </div>
        </details>
      </div>
    </div>
  </div>

  <div class="widget-dock">
    <div class="dock-col" id="dockLeft"></div>
    <div class="dock-col" id="dockRight"></div>
  </div>

  <div class="backdrop" id="modalBackdrop"></div>

  <script>
    console.log('[BioSphere] スクリプト初期化開始');
    /* Window manager */
    const widgetManager = (() => {
      const widgets = new Map();
      const zBase = 20;
      let zCursor = zBase;
      let dragging = null;

      const syncButtons = (el, action, active) => {
        el.querySelectorAll(`[data-action="${action}"]`).forEach(btn => {
          btn.setAttribute('aria-pressed', active);
        });
      };

      const register = (id) => {
        const el = document.getElementById(id);
        if(!el) return;
        el.dataset.widgetId = id;
        widgets.set(id, { el, restoreRect:null, z:zCursor++ });
        el.style.zIndex = widgets.get(id).z;
        syncButtons(el, 'minimize', false);
        syncButtons(el, 'maximize', false);
      };

      const saveRect = (el) => {
        const rect = el.getBoundingClientRect();
        return {
          left: el.style.left || `${rect.left}px`,
          top: el.style.top || `${rect.top}px`,
          width: el.style.width || `${rect.width}px`,
          height: el.style.height || `${rect.height}px`,
        };
      };

      const applyRect = (el, rect) => {
        if(!rect) return;
        el.style.left = rect.left;
        el.style.top = rect.top;
        el.style.width = rect.width;
        el.style.height = rect.height;
      };

      const focus = (id) => {
        const entry = widgets.get(id); if(!entry) return;
        entry.z = ++zCursor;
        entry.el.style.zIndex = entry.z;
      };

      const minimize = (id) => {
        const entry = widgets.get(id); if(!entry) return;
        const { el } = entry;
        const willMinimize = !el.classList.contains('is-minimized');
        if(willMinimize && !el.classList.contains('is-maximized')){
          entry.restoreRect = saveRect(el);
        }
        el.classList.toggle('is-minimized', willMinimize);
        if(willMinimize) el.classList.remove('is-maximized');
        syncButtons(el, 'minimize', willMinimize);
        if(!willMinimize) clampToViewport(el);
      };

      const maximize = (id) => {
        const entry = widgets.get(id); if(!entry) return;
        const { el } = entry;
        if(el.classList.contains('is-maximized')){
          el.classList.remove('is-maximized');
          syncButtons(el, 'maximize', false);
          applyRect(el, entry.restoreRect);
          clampToViewport(el);
          return;
        }
        entry.restoreRect = saveRect(el);
        el.classList.add('is-maximized');
        el.classList.remove('is-minimized');
        syncButtons(el, 'maximize', true);
        syncButtons(el, 'minimize', false);
      };

      const clampToViewport = (el) => {
        const rect = el.getBoundingClientRect();
        const vw = window.innerWidth; const vh = window.innerHeight;
        let left = rect.left; let top = rect.top;
        left = Math.min(Math.max(left, 8), vw - rect.width - 8);
        top = Math.min(Math.max(top, 8), vh - rect.height - 8);
        el.style.left = `${left}px`; el.style.top = `${top}px`;
      };

      const startDrag = (e) => {
        const header = e.target.closest('.widget-header');
        if(!header || e.target.closest('[data-action]')) return;
        const id = header.dataset.widgetId || header.parentElement?.dataset.widgetId;
        const entry = widgets.get(id); if(!entry) return;
        const el = entry.el;
        if(el.classList.contains('is-maximized')) return;
        focus(id);
        const rect = el.getBoundingClientRect();
        dragging = { id, offsetX: e.clientX - rect.left, offsetY: e.clientY - rect.top, pointerId:e.pointerId };
        header.setPointerCapture(e.pointerId);
        el.classList.add('dragging');
      };

      const doDrag = (e) => {
        if(!dragging || e.pointerId !== dragging.pointerId) return;
        const entry = widgets.get(dragging.id); if(!entry) return;
        const el = entry.el;
        const left = e.clientX - dragging.offsetX;
        const top = e.clientY - dragging.offsetY;
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
      };

      const endDrag = (e) => {
        if(!dragging || (e && e.pointerId !== dragging.pointerId)) { return; }
        const entry = widgets.get(dragging.id);
        if(entry){
          clampToViewport(entry.el);
          entry.el.classList.remove('dragging');
        }
        dragging = null;
      };

      const cleanupOverlays = () => {
        document.querySelectorAll('.backdrop').forEach(el=>{
          el.classList.remove('active');
          el.style.pointerEvents = 'none';
        });
        document.querySelectorAll('.widget').forEach(el=>el.style.pointerEvents='auto');
        if(typeof mapStage !== 'undefined' && mapStage){ mapStage.style.pointerEvents = 'auto'; }
        if(typeof canvasHost !== 'undefined' && canvasHost){ canvasHost.style.pointerEvents = 'auto'; }
      };

      const panicReset = () => {
        cleanupOverlays();
        widgets.forEach(({el, restoreRect}) => {
          el.classList.remove('is-maximized', 'is-minimized', 'dragging');
          syncButtons(el, 'maximize', false);
          syncButtons(el, 'minimize', false);
          applyRect(el, restoreRect);
          clampToViewport(el);
        });
      };

      document.addEventListener('pointerdown', (e)=>{
        const widget = e.target.closest('.widget');
        if(widget){
          focus(widget.dataset.widgetId);
        }
        if(e.target.closest('[data-action]')){ e.stopPropagation(); }
      }, true);

      document.addEventListener('click', (e) => {
        const btn = e.target.closest('[data-action]');
        if(!btn) return;
        const id = btn.dataset.widgetId || btn.closest('.widget')?.dataset.widgetId;
        const action = btn.dataset.action;
        if(action === 'minimize') minimize(id);
        if(action === 'maximize') maximize(id);
      });

      document.addEventListener('pointerdown', startDrag);
      document.addEventListener('pointermove', doDrag);
      document.addEventListener('pointerup', endDrag);
      document.addEventListener('pointercancel', endDrag);

      window.addEventListener('resize', () => widgets.forEach(({el}) => clampToViewport(el)));

      return { register, minimize, maximize, clampToViewport, panicReset, focus };
    })();

    ['hudWidget','summaryWidget','controlsWidget','legendWidget','settingsWidget'].forEach(widgetManager.register);

    /* Canvas manager */
    const mapStage = document.getElementById('mapStage');
    const canvasHost = document.getElementById('canvasHost');
    if(!mapStage || !canvasHost){ throw new Error('#mapStage / #canvasHost が見つかりません'); }
    const canvasDebug = document.getElementById('canvasDebug');
    const canvasDebugToggle = document.getElementById('canvasDebugToggle');
    const canvasSizeStat = document.getElementById('canvasSizeStat');
    const canvasDprStat = document.getElementById('canvasDprStat');
    const canvasRenderStat = document.getElementById('canvasRenderStat');
    const canvasTilesStat = document.getElementById('canvasTilesStat');
    const canvasStatus = document.getElementById('canvasStatus');
    const modalBackdrop = document.getElementById('modalBackdrop');
    let pInstance = null;
    let simFrame = null;
    let resizeObserver = null;
    let debugEnabled = true;
    const query = new URLSearchParams(location.search);
    if(query.has('debug')){ debugEnabled = query.get('debug') === '1'; }
    let stageRetry = 0;
    const maxStageRetry = 10;
    const renderStats = { lastRenderMs: 0, worldTiles: 0 };
    let drawErrored = false;

    /* Simulation */
    const legendList = document.getElementById('legendList');
    const presetButtons = document.querySelectorAll('[data-preset]');
    const toggleHearts = document.getElementById('toggleHearts');
    const toggleFlashes = document.getElementById('toggleFlashes');
    const toggleTrails = document.getElementById('toggleTrails');
    const toggleVectors = document.getElementById('toggleVectors');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const stepBtn = document.getElementById('stepBtn');
    const panicBtn = document.getElementById('panicBtn');
    const extinctionModeCheckbox = document.getElementById('modeExtinction');
    const behaviorControls = document.getElementById('behaviorControls');
    const zoomSlider = document.getElementById('zoomSlider');

    const terrainTypes = [
      { key:'grass', name:'草原', color:'#1f6f3f', texture:'#2b8a4f', plantK:0.65, cover:0.1, isWater:false, isRock:false },
      { key:'forest', name:'森林', color:'#19341f', texture:'#225028', plantK:0.8, cover:0.4, isWater:false, isRock:false },
      { key:'shrub', name:'低木地', color:'#245c3c', texture:'#2f7a4c', plantK:0.7, cover:0.25, isWater:false, isRock:false },
      { key:'rock', name:'岩地', color:'#545b63', texture:'#737b84', plantK:0, cover:0.05, isWater:false, isRock:true },
      { key:'water', name:'水域', color:'#1b3b62', texture:'#27517f', plantK:0, cover:0, isWater:true, isRock:false },
      { key:'wetland', name:'湿地', color:'#1f4f58', texture:'#2f7a88', plantK:0.9, cover:0.18, isWater:false, isRock:false },
      { key:'sand', name:'砂地', color:'#7a623c', texture:'#8b754f', plantK:0.3, cover:0.05, isWater:false, isRock:false },
    ];

    const speciesLibrary = {
      deer:{ name:'シカ系', diet:'herb', color:'#9be070', outline:'#0d190a', inner:'#d7f7b2', speed:0.6, sociality:0.5, behavior:'herd', metabolism:0.002, satietyDecay:0.003, reproduction: {interval:1400, litter:[1,2]}, vision:4, coverAffinity:0.2 },
      wolf:{ name:'オオカミ系', diet:'carn', color:'#ff9f70', outline:'#3a1205', inner:'#ffc9a6', speed:0.8, sociality:0.7, behavior:'pack', metabolism:0.0022, satietyDecay:0.003, reproduction: {interval:1800, litter:[2,3]}, vision:5, coverAffinity:-0.1 },
      zebra:{ name:'シマウマ系', diet:'herb', color:'#d8f0ff', outline:'#101820', inner:'#6dc6ff', speed:0.75, sociality:0.7, behavior:'herd', metabolism:0.002, satietyDecay:0.003, reproduction: {interval:1600, litter:[1,1]}, vision:4, coverAffinity:0 },
      lion:{ name:'ライオン系', diet:'carn', color:'#f1c56a', outline:'#4e2c05', inner:'#ffe2a6', speed:0.7, sociality:0.6, behavior:'pack', metabolism:0.0024, satietyDecay:0.003, reproduction:{interval:1900, litter:[2,3]}, vision:5, coverAffinity:-0.05 },
      capybara:{ name:'カピバラ系', diet:'herb', color:'#cdb18a', outline:'#302215', inner:'#f3e3c8', speed:0.45, sociality:0.4, behavior:'den', metabolism:0.0018, satietyDecay:0.0025, reproduction:{interval:1500, litter:[2,4]}, vision:3, coverAffinity:0.25 },
      otter:{ name:'カワウソ系', diet:'carn', color:'#9cc4ff', outline:'#0c1d32', inner:'#d7e7ff', speed:0.6, sociality:0.5, behavior:'ambush', metabolism:0.0021, satietyDecay:0.0028, reproduction:{interval:1600, litter:[1,2]}, vision:4, coverAffinity:0.15 }
    };

    const presets = {
      temperate: {
        label:'温帯森林',
        description:'四季と豊かな下草。冬の終わりにオオカミが群れを作る。',
        climate:{ temp: [10,18,12,2], rain:[0.22,0.32,0.25,0.16] },
        animals:[
          { species:'deer', count:32 },
          { species:'wolf', count:12 },
        ],
        terrain: { forest:0.34, shrub:0.18, wetland:0.08, water:0.08, rock:0.08, sand:0.02 }
      },
      savanna: {
        label:'サバンナ',
        description:'乾季が長く、雨季に草木が爆発的成長。ライオンは水場周りで協調。',
        climate:{ temp:[24,31,27,19], rain:[0.1,0.32,0.07,0.04] },
        animals:[
          { species:'zebra', count:34 },
          { species:'lion', count:14 },
        ],
        terrain: { grass:0.34, shrub:0.2, sand:0.14, water:0.08, rock:0.05, wetland:0.05 }
      },
      wetland: {
        label:'湿地',
        description:'岩の巣穴が点在する大きな沼地。カワウソは葦際で待ち伏せ。',
        climate:{ temp:[18,24,15,9], rain:[0.32,0.44,0.28,0.22] },
        animals:[
          { species:'capybara', count:28 },
          { species:'otter', count:12 },
        ],
        terrain: { wetland:0.34, water:0.18, forest:0.16, rock:0.09, grass:0.1, shrub:0.05 }
      }
    };

    const state = {
      running:false,
      season:0,
      temp:12,
      rain:0,
      score:0,
      animals:[],
      plants:[],
      terrain:[],
      dens: new Set(),
      reproductionEvents:[],
      huntEvents:[],
      view:{ scale:1, offsetX:0, offsetY:0 },
      gridW:72,
      gridH:44,
      tile:18,
      climate: presets.temperate.climate,
      endAllExtinct:false,
    };

    function clampScale(value){ return Math.min(Math.max(value, 0.5), 2.5); }

    function recenterView(){
      const rect = measureStage();
      const worldW = state.gridW * state.tile * state.view.scale;
      const worldH = state.gridH * state.tile * state.view.scale;
      state.view.offsetX = (rect.width - worldW)/2;
      state.view.offsetY = (rect.height - worldH)/2;
    }

    function syncZoomSlider(){
      if(!zoomSlider) return;
      zoomSlider.value = clampScale(state.view.scale).toFixed(2);
    }

    function updateScale(newScale, anchorX=null, anchorY=null){
      const rect = measureStage();
      const anchor = {
        x: anchorX ?? rect.width/2,
        y: anchorY ?? rect.height/2,
      };
      const prevScale = state.view.scale || 1;
      const worldX = (anchor.x - state.view.offsetX) / (state.tile * prevScale);
      const worldY = (anchor.y - state.view.offsetY) / (state.tile * prevScale);
      state.view.scale = clampScale(newScale);
      const scaledTile = state.tile * state.view.scale;
      state.view.offsetX = anchor.x - worldX * scaledTile;
      state.view.offsetY = anchor.y - worldY * scaledTile;
      syncZoomSlider();
    }

    function measureStage(){
      const rect = canvasHost.getBoundingClientRect();
      return { width: Math.round(rect.width), height: Math.round(rect.height) };
    }

    function setCanvasStatus(message, isError=false){
      if(!canvasStatus) return;
      if(message){
        canvasStatus.textContent = message;
        canvasStatus.style.borderColor = isError ? 'rgba(255,120,120,0.65)' : 'rgba(110,200,255,0.45)';
        canvasStatus.style.background = isError ? 'rgba(55,10,10,0.82)' : 'rgba(10,30,55,0.7)';
        canvasStatus.style.color = isError ? '#ffb0b0' : '#cde7ff';
        canvasStatus.classList.remove('hidden');
      } else {
        canvasStatus.classList.add('hidden');
      }
    }

    function showErrorModal(message){
      if(!modalBackdrop) return;
      modalBackdrop.innerHTML = '';
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.innerHTML = `<h3>描画エラー</h3><p>${message}</p><button class="btn" id="modalClose">閉じる</button>`;
      modalBackdrop.appendChild(modal);
      modalBackdrop.classList.add('active');
      const closeBtn = modal.querySelector('#modalClose');
      closeBtn?.addEventListener('click', ()=>modalBackdrop.classList.remove('active'));
    }

    function updateDebugPanel(rect){
      if(!debugEnabled){
        canvasDebug.classList.add('off');
        return;
      }
      canvasDebug.classList.remove('off');
      const dpr = Math.round((window.devicePixelRatio||1)*100)/100;
      canvasSizeStat.textContent = `キャンバス: ${rect.width}x${rect.height}`;
      canvasDprStat.textContent = `DPR: ${dpr}`;
      canvasRenderStat.textContent = `最終描画: ${renderStats.lastRenderMs.toFixed(1)} ms`;
      canvasTilesStat.textContent = `タイル数: ${renderStats.worldTiles}`;
      if(rect.width===0 || rect.height===0){
        canvasSizeStat.classList.add('is-error');
      } else {
        canvasSizeStat.classList.remove('is-error');
      }
    }

    function ensureCanvasSize(){
      if(!pInstance) return false;
      const rect = measureStage();
      const dpr = window.devicePixelRatio || 1;
      pInstance.pixelDensity(dpr);
      if(rect.width && rect.height){
        pInstance.resizeCanvas(rect.width, rect.height, true);
        updateDebugPanel(rect);
        setCanvasStatus('');
        stageRetry = 0;
        return true;
      }
      updateDebugPanel(rect);
      if(stageRetry < maxStageRetry){
        stageRetry++;
        setCanvasStatus(`キャンバス準備待機中 (${stageRetry}/${maxStageRetry})`);
        setTimeout(()=>{ ensureCanvasSize(); renderOnce('recover'); }, 100);
      } else {
        setCanvasStatus('キャンバス領域が 0x0 のため初期化に失敗しました', true);
      }
      return false;
    }

    function createCanvasSafely(sk, onSuccess=null){
      const rect = measureStage();
      if(rect.width && rect.height){
        const cnv = sk.createCanvas(Math.max(1, rect.width), Math.max(1, rect.height));
        cnv.parent(canvasHost);
        cnv.canvas.id = 'mapCanvas';
        setCanvasStatus('');
        stageRetry = 0;
        console.log(`[BioSphere] canvas created ${rect.width}x${rect.height}`);
        if(typeof onSuccess === 'function'){ onSuccess(); }
        return cnv;
      }
      if(stageRetry < maxStageRetry){
        stageRetry++;
        setCanvasStatus(`キャンバス初期化を再試行中 (${stageRetry}/${maxStageRetry})`);
        setTimeout(()=>createCanvasSafely(p, onSuccess), 100);
      } else {
        setCanvasStatus('キャンバス領域が 0x0 のため描画できません', true);
      }
      return null;
    }

    const legendEntries = [
      ...terrainTypes.map(t=>({label:t.name, color:t.color})),
      { label:'草食動物', color:'#9be070' },
      { label:'肉食動物', color:'#ff9f70' },
      { label:'巣', color:'#f5d97a' }
    ];

    function renderOnce(reason='manual'){
      if(!pInstance) return;
      const rect = measureStage();
      if(!rect.width || !rect.height){
        updateDebugPanel(rect);
        requestAnimationFrame(()=>renderOnce('recover')); 
        return;
      }
      const start = performance.now();
      ensureCanvasSize();
      pInstance.redraw();
      renderStats.lastRenderMs = performance.now() - start;
      updateDebugPanel(rect);
    }

    function startSimLoop(){
      if(simFrame) return;
      const tick = () => {
        if(!state.running){ simFrame = null; return; }
        stepSim();
        renderOnce('sim');
        simFrame = requestAnimationFrame(tick);
      };
      simFrame = requestAnimationFrame(tick);
    }

    function stopSimLoop(){
      state.running = false;
      if(simFrame){ cancelAnimationFrame(simFrame); simFrame = null; }
    }

    function renderLegend(){
      legendList.innerHTML = '';
      legendEntries.forEach(t => {
        const row = document.createElement('div');
        row.className = 'legend-row';
        row.innerHTML = `<span class="legend-swatch" style="background:${t.color}"></span><span>${t.label}</span>`;
        legendList.appendChild(row);
      });
    }
    renderLegend();
    toggleHearts.addEventListener('change', ()=>renderOnce('overlay'));
    toggleFlashes.addEventListener('change', ()=>renderOnce('overlay'));
    toggleTrails.addEventListener('change', ()=>renderOnce('overlay'));
    toggleVectors.addEventListener('change', ()=>renderOnce('overlay'));
    zoomSlider.addEventListener('input', ()=>{ updateScale(parseFloat(zoomSlider.value||'1')); renderOnce('zoom'); });

    /* Core sim helpers */
    const clamp01 = (v) => Math.min(1, Math.max(0, v));
    const randBetween = (min,max) => min + Math.random()*(max-min);
    const wrap = (v, max) => (v + max) % max;

    function createTerrain(weights){
      const cumulative = [];
      let sum = 0;
      const keys = Object.keys(weights);
      keys.forEach(k=>{ sum += weights[k]; cumulative.push({key:k, end:sum}); });
      const total = sum || 1;
      const arr=[];
      for(let i=0;i<state.gridW*state.gridH;i++){
        const r = Math.random()*total;
        const found = cumulative.find(c=>r<=c.end) || cumulative[cumulative.length-1];
        arr.push(found.key);
      }
      return arr;
    }

    function setupDens(){
      state.dens.clear();
      for(let i=0;i<state.terrain.length;i++){
        const t = terrainTypes.find(tt=>tt.key===state.terrain[i]);
        if(!t || t.isWater || t.isRock) continue;
        if(t.key==='rock' || t.key==='forest'){
          if(Math.random()<0.06) state.dens.add(i);
        } else if(t.key==='shrub' && Math.random()<0.04){
          state.dens.add(i);
        }
      }
    }

    function initPlants(){
      state.plants = state.terrain.map(t => {
        const terrain = terrainTypes.find(tt=>tt.key===t);
        if(terrain.isWater || terrain.isRock) return 0;
        return randBetween(0.2, terrain.plantK);
      });
    }

    function spawnAnimals(animalDefs){
      state.animals = [];
      animalDefs.forEach(def => {
        const sp = speciesLibrary[def.species];
        if(!sp) return;
        for(let i=0;i<def.count;i++){
          state.animals.push(makeAnimal(def.species));
        }
      });
    }

    function makeAnimal(speciesKey){
      const sp = speciesLibrary[speciesKey];
      return {
        id:crypto.randomUUID(),
        species: speciesKey,
        diet: sp.diet,
        x: Math.random()*state.gridW,
        y: Math.random()*state.gridH,
        vx: randBetween(-0.2,0.2),
        vy: randBetween(-0.2,0.2),
        energy: 1,
        satiety: 0.6,
        age: 0,
        lastBreed:0,
        trail:[],
      };
    }

    function applyPreset(key){
      const preset = presets[key];
      if(!preset) return;
      state.climate = preset.climate;
      state.season = 0; state.score = 0; state.temp = preset.climate.temp[0]; state.rain = preset.climate.rain[0];
      state.terrain = createTerrain(preset.terrain);
      setupDens();
      initPlants();
      spawnAnimals(preset.animals);
      drawErrored = false;
      renderSummary();
      updateHUD();
      const note = preset.description || '';
      document.getElementById('presetInfo').textContent = `プリセット: ${preset.label}${note ? ' — ' + note : ''}`;
      renderStats.worldTiles = state.gridW * state.gridH;
      recenterView();
      syncZoomSlider();
      renderOnce('preset');
    }

    presetButtons.forEach(btn => btn.addEventListener('click', ()=>{
      applyPreset(btn.dataset.preset);
      state.running = true;
      startSimLoop();
    }));

    function renderBehaviorControls(){
      behaviorControls.innerHTML = '';
      const behaviorLabels = { herd:'群れ', pack:'群れ狩り', ambush:'待ち伏せ', den:'巣ごもり', wander:'放浪' };
      Object.entries(speciesLibrary).forEach(([key, sp]) => {
        const row = document.createElement('div');
        row.style.display = 'grid';
        row.style.gridTemplateColumns = '140px 1fr';
        row.style.alignItems = 'center';
        const label = document.createElement('div');
        label.textContent = sp.name;
        const select = document.createElement('select');
        ['herd','pack','ambush','den','wander'].forEach(mode => {
          const opt = document.createElement('option');
          opt.value = mode; opt.textContent = behaviorLabels[mode] || mode;
          if(sp.behavior===mode) opt.selected = true;
          select.appendChild(opt);
        });
        select.addEventListener('change', ()=>{
          speciesLibrary[key].behavior = select.value;
        });
        row.appendChild(label); row.appendChild(select);
        behaviorControls.appendChild(row);
      });
    }
    renderBehaviorControls();

    const hudEls = {
      pop: document.getElementById('hudPop'),
      season: document.getElementById('hudSeason'),
      temp: document.getElementById('hudTemp'),
      rain: document.getElementById('hudRain'),
      score: document.getElementById('hudScore'),
    };

    function updateHUD(){
      hudEls.pop.textContent = state.animals.length;
      hudEls.season.textContent = ['春','夏','秋','冬'][state.season%4];
      hudEls.temp.textContent = `${state.temp.toFixed(1)}℃`;
      hudEls.rain.textContent = state.rain.toFixed(2);
      hudEls.score.textContent = state.score.toFixed(0);
    }

    function renderSummary(){
      const counts = {};
      state.animals.forEach(a => { counts[a.species] = (counts[a.species]||0)+1; });
      const lines = Object.entries(counts).map(([k,v])=>`${speciesLibrary[k]?.name||k}: ${v}`);
      document.getElementById('genSummary').textContent = lines.join(' / ') || 'データなし';
    }

    /* Simulation */
    let sketch = (sk) => {
      pInstance = sk;
      let pan = { active:false, startX:0, startY:0, originX:0, originY:0 };

      sk.setup = () => {
        canvasHost.innerHTML = '';
        const finishSetup = () => {
          sk.pixelDensity(window.devicePixelRatio || 1);
          sk.noLoop();
          applyPreset('temperate');
          if(!resizeObserver){
            resizeObserver = new ResizeObserver(()=>{ ensureCanvasSize(); renderOnce('resize'); });
            resizeObserver.observe(mapStage);
          }
          const rect = measureStage();
          console.log(`[BioSphere] p5 ready / map dims ${rect.width}x${rect.height}`);
        };
        createCanvasSafely(sk, finishSetup);
      };

      sk.windowResized = () => {
        ensureCanvasSize();
        renderOnce('resize');
      };

      sk.draw = () => {
        if(drawErrored) return;
        try {
          sk.background('#05080f');
          drawTerrain(sk);
          drawPlants(sk);
          drawDens(sk);
          drawTrails(sk);
          drawAnimals(sk);
          drawEvents(sk);
        } catch(err){
          const debugMode = window.__BIO_DEBUG__ === true;
          if(!debugMode){
            drawErrored = true;
            stopSimLoop();
            sk.noLoop();
          }
          console.error('[BioSphere] draw error', err);
          showErrorModal(`描画中にエラーが発生しました: ${err.message}`);
        }
      };
      console.log('[BioSphere] draw handlers ready');

      function worldToScreen(x,y){
        return {
          x: x*state.tile*state.view.scale + state.view.offsetX,
          y: y*state.tile*state.view.scale + state.view.offsetY
        };
      }

      function drawTerrain(sk){
        ensureValidP5(sk);
        for(let y=0;y<state.gridH;y++){
          for(let x=0;x<state.gridW;x++){
            const idx = y*state.gridW+x;
            const tKey = state.terrain[idx];
            const cellType = terrainTypes.find(t=>t.key===tKey) || terrainTypes[0];
            const pos = worldToScreen(x,y);
            const size = state.tile*state.view.scale;
            sk.noStroke();
            const c = sk.color(cellType.color);
            c.setAlpha(190);
            sk.fill(c);
            sk.rect(pos.x, pos.y, size, size);
            sk.stroke(cellType.texture);
            sk.strokeWeight(1);
            if(tKey==='forest'){
              sk.line(pos.x+size*0.3, pos.y, pos.x+size*0.7, pos.y+size);
              sk.line(pos.x, pos.y+size*0.4, pos.x+size, pos.y+size*0.6);
            } else if(tKey==='water'){
              sk.noFill();
              sk.beginShape();
              curveVertexSafe(sk, pos.x, pos.y+size*0.25);
              curveVertexSafe(sk, pos.x+size*0.15, pos.y+size*0.35);
              curveVertexSafe(sk, pos.x+size*0.45, pos.y+size*0.55);
              curveVertexSafe(sk, pos.x+size*0.75, pos.y+size*0.7);
              curveVertexSafe(sk, pos.x+size, pos.y+size*0.82);
              sk.endShape();
            } else if(tKey==='rock'){
              sk.fill(cellType.texture); sk.noStroke();
              sk.triangle(pos.x+size*0.2,pos.y+size*0.8,pos.x+size*0.5,pos.y+size*0.2,pos.x+size*0.8,pos.y+size*0.9);
            } else if(tKey==='wetland'){
              sk.noFill(); sk.stroke(cellType.texture);
              sk.ellipse(pos.x+size*0.4,pos.y+size*0.6,size*0.4,size*0.25);
            } else if(tKey==='sand'){
              sk.noFill(); sk.stroke(cellType.texture);
              sk.line(pos.x+size*0.2,pos.y+size*0.7,pos.x+size*0.8,pos.y+size*0.65);
            } else if(tKey==='shrub'){
              sk.noStroke(); sk.fill(cellType.texture);
              sk.circle(pos.x+size*0.3,pos.y+size*0.4,size*0.2);
              sk.circle(pos.x+size*0.6,pos.y+size*0.5,size*0.25);
            }
          }
        }
      }

      function drawPlants(sk){
        sk.noStroke();
        state.plants.forEach((v,idx)=>{
          if(v<=0.01) return;
          const x = idx % state.gridW;
          const y = Math.floor(idx / state.gridW);
          const pos = worldToScreen(x,y);
          const size = state.tile*state.view.scale;
          sk.fill(100,200,120, clamp01(v)*180 + 40);
          sk.circle(pos.x+size/2, pos.y+size/2, Math.max(4, size*0.4*v));
        });
      }

      function drawDens(sk){
        sk.noStroke();
        state.dens.forEach(idx => {
          const x = idx % state.gridW; const y = Math.floor(idx/state.gridW);
          const pos = worldToScreen(x,y);
          const size = state.tile*state.view.scale;
          sk.fill('#f5d97a');
          sk.rect(pos.x+size*0.28,pos.y+size*0.28,size*0.44,size*0.44,4);
        });
      }

      function drawTrails(sk){
        if(!toggleTrails.checked) return;
        state.animals.forEach(a=>{
          if(!a.trail || a.trail.length < 2) return;
          sk.noFill();
          sk.stroke('rgba(160,210,255,0.45)');
          sk.strokeWeight(Math.max(1, state.tile*state.view.scale*0.06));
          sk.beginShape();
          a.trail.forEach(pt => {
            const pos = worldToScreen(pt.x, pt.y);
            sk.vertex(pos.x, pos.y);
          });
          const head = worldToScreen(a.x, a.y);
          sk.vertex(head.x, head.y);
          sk.endShape();
        });
      }

      function drawAnimals(sk){
        state.animals.forEach(a=>{
          const pos = worldToScreen(a.x,a.y);
          const size = state.tile*state.view.scale;
          const sp = speciesLibrary[a.species];
          if(!sp) return;
          sk.stroke(sp.outline); sk.strokeWeight(1.6); sk.fill(sp.color);
          if(sp.diet==='herb'){
            sk.circle(pos.x, pos.y, size*0.72);
            sk.fill(sp.inner); sk.noStroke();
            sk.circle(pos.x, pos.y, size*0.3);
          } else {
            sk.triangle(pos.x-size*0.4,pos.y+size*0.4,pos.x+size*0.4,pos.y+size*0.4,pos.x,pos.y-size*0.5);
            sk.fill(sp.inner); sk.noStroke();
            sk.triangle(pos.x-size*0.18,pos.y+size*0.18,pos.x+size*0.18,pos.y+size*0.18,pos.x,pos.y-size*0.24);
          }
          if(toggleVectors.checked){
            const mag = Math.hypot(a.vx, a.vy) || 0;
            if(mag > 0.001){
              const dirX = a.vx / mag;
              const dirY = a.vy / mag;
              const len = size * 0.9;
              sk.stroke('rgba(240,255,255,0.85)');
              sk.strokeWeight(Math.max(1, size*0.08));
              sk.line(pos.x, pos.y, pos.x + dirX*len, pos.y + dirY*len);
              sk.strokeWeight(Math.max(1, size*0.05));
              sk.line(pos.x + dirX*len, pos.y + dirY*len, pos.x + dirX*len - dirY*len*0.25, pos.y + dirY*len + dirX*len*0.25);
              sk.line(pos.x + dirX*len, pos.y + dirY*len, pos.x + dirX*len + dirY*len*0.25, pos.y + dirY*len - dirX*len*0.25);
            }
          }
        });
      }

      function drawEvents(sk){
        const now = performance.now();
        state.reproductionEvents = state.reproductionEvents.filter(ev => now-ev.time < 900);
        state.huntEvents = state.huntEvents.filter(ev => now-ev.time < 480);

        if(toggleHearts.checked){
          state.reproductionEvents.forEach(ev => {
            const t = (now-ev.time)/900;
            const pos = worldToScreen(ev.x, ev.y);
            sk.noStroke(); sk.fill(`rgba(255,120,200,${1-t})`);
            sk.textSize(state.tile*state.view.scale*0.8);
            sk.text('♡', pos.x, pos.y);
          });
        }
        if(toggleFlashes.checked){
          state.huntEvents.forEach(ev => {
            const t = (now-ev.time)/480;
            const pos = worldToScreen(ev.x, ev.y);
            sk.noFill(); sk.stroke(`rgba(255,180,80,${1-t})`); sk.strokeWeight(3);
            const r = state.tile*state.view.scale*(0.6 + t*0.6);
            sk.circle(pos.x, pos.y, r);
          });
        }
      }

      const ensureValidP5 = (sk) => {
        if(!sk || typeof sk.rect !== 'function' || typeof sk.beginShape !== 'function'){
          throw new Error('drawTerrain: invalid p5 instance (sk) passed');
        }
      };

      const curveVertexSafe = (sk, x, y) => {
        if(sk && typeof sk.curveVertex === 'function') return sk.curveVertex(x, y);
        if(sk && typeof sk.vertex === 'function') return sk.vertex(x, y);
      };

      const curveSafe = (sk, x1,y1,x2,y2,x3,y3,x4,y4) => {
        if(sk && typeof sk.curve === 'function') return sk.curve(x1,y1,x2,y2,x3,y3,x4,y4);
        if(sk && typeof sk.bezier === 'function') return sk.bezier(x1,y1,x2,y2,x3,y3,x4,y4);
      };

      sk.mouseWheel = (event) => {
        const factor = event.delta > 0 ? 0.92 : 1.08;
        updateScale(state.view.scale * factor, sk.mouseX, sk.mouseY);
        renderOnce('zoom');
      };

      sk.mousePressed = () => {
        if(sk.mouseButton === sk.CENTER || (sk.mouseButton === sk.LEFT && sk.keyIsDown(32))){
          pan.active = true; pan.startX = sk.mouseX; pan.startY = sk.mouseY; pan.originX = state.view.offsetX; pan.originY = state.view.offsetY;
        }
      };
      sk.mouseDragged = () => {
        if(pan.active){
          state.view.offsetX = pan.originX + (sk.mouseX - pan.startX);
          state.view.offsetY = pan.originY + (sk.mouseY - pan.startY);
          renderOnce('pan');
        }
      };
      sk.mouseReleased = () => { if(pan.active) renderOnce('pan'); pan.active=false; };

      const resetViewBtn = document.getElementById('resetView');
      if(resetViewBtn){
        resetViewBtn.addEventListener('click', ()=>{
          state.view.scale = 1;
          recenterView();
          syncZoomSlider();
          renderOnce('reset');
        });
      }
      if(startBtn){ startBtn.addEventListener('click', ()=> { state.running=true; startSimLoop(); }); }
      if(stopBtn){ stopBtn.addEventListener('click', ()=> { stopSimLoop(); renderOnce('stop'); }); }
      if(stepBtn){ stepBtn.addEventListener('click', ()=> { stopSimLoop(); stepSim(); renderOnce('step'); }); }
      if(panicBtn){
        panicBtn.addEventListener('click', ()=>{
          widgetManager.panicReset();
          state.view = { scale:1, offsetX:0, offsetY:0 };
          recenterView();
          syncZoomSlider();
          stopSimLoop();
          drawErrored = false;
          renderOnce('panic');
        });
      }
    };

    function stepSim(){
      const stepsPerFrame = 2;
      for(let s=0;s<stepsPerFrame;s++){
        updateClimate();
        growPlants();
        updateAnimals();
        checkEndCondition();
      }
      updateHUD();
      renderSummary();
    }

    function updateClimate(){
      const seasonLength = 2200;
      state.score += 0.05;
      state.temp += (state.climate.temp[state.season%4] - state.temp) * 0.002;
      state.rain += (state.climate.rain[state.season%4] - state.rain) * 0.002;
      state.score = Math.max(0, state.score);
      if(state.score > seasonLength){
        state.season++; state.score = 0;
      }
    }

    function growPlants(){
      state.plants = state.plants.map((v,i)=>{
        const terrain = terrainTypes.find(t=>t.key===state.terrain[i]);
        if(!terrain || terrain.isWater || terrain.isRock) return 0;
        const growth = 0.001 + state.rain*0.002;
        const K = terrain.plantK;
        return clamp01(v + growth*v*(K - v));
      });
    }

    function updateAnimals(){
      const preyIndex = new Map();
      state.animals.forEach((a,i)=>{ if(a.diet==='herb') preyIndex.set(a.id, i); });
      const alerts = [];
      const trailLimit = 18;

      state.animals.forEach(a => {
        const sp = speciesLibrary[a.species];
        if(!sp) return;
        const hunger = 1 - a.satiety;
        const satiatedBrake = a.satiety>0.8 ? 0.35 : 1;
        const speed = (sp.speed + hunger*0.3) * satiatedBrake;
        if(Math.random() < speed){
          const dir = chooseDirection(a, sp, alerts);
          a.vx = dir.x; a.vy = dir.y;
          const before = {x:a.x, y:a.y};
          a.x = wrap(a.x + a.vx, state.gridW);
          a.y = wrap(a.y + a.vy, state.gridH);
          a.trail = [...(a.trail||[]), before].slice(-trailLimit);
        }
        a.satiety = clamp01(a.satiety - sp.satietyDecay);
        a.energy = clamp01(a.energy - sp.metabolism + a.satiety*0.0004);
        a.age += 1;
        a.lastBreed += 1;

        if(a.diet==='herb') consumePlant(a, sp, hunger);
        else huntPrey(a, sp, alerts);

        tryReproduce(a, sp);
      });

      state.animals = state.animals.filter(a => a.energy>0 && a.age<8000);
    }

    function chooseDirection(a, sp, alerts){
      let vec = {x: randBetween(-0.3,0.3), y: randBetween(-0.3,0.3)};
      const neighbors = state.animals.filter(b => b !== a && b.diet===a.diet && dist(a,b)<3);
      if(sp.behavior==='herd' && neighbors.length){
        const cohesion = neighbors.reduce((acc,b)=>({x:acc.x+(b.x-a.x), y:acc.y+(b.y-a.y)}), {x:0,y:0});
        vec.x += cohesion.x/neighbors.length * 0.05;
        vec.y += cohesion.y/neighbors.length * 0.05;
      }
      if(neighbors.length){
        const separation = neighbors.reduce((acc,b)=>{
          const d = dist(a,b)+0.01;
          return {x: acc.x - (b.x-a.x)/(d*d), y: acc.y - (b.y-a.y)/(d*d)};
        }, {x:0,y:0});
        vec.x += separation.x * 0.08;
        vec.y += separation.y * 0.08;
      }
      if(sp.diet==='herb'){
        const food = findFoodPatch(a);
        if(food){
          vec.x += (food.x - a.x)*0.04;
          vec.y += (food.y - a.y)*0.04;
        }
      }
      if(sp.behavior==='pack' && a.diet==='carn' && alerts.length){
        const signal = alerts.reduce((acc,al)=>({x:acc.x+al.x-a.x, y:acc.y+al.y-a.y}), {x:0,y:0});
        vec.x += signal.x/alerts.length * 0.03;
        vec.y += signal.y/alerts.length * 0.03;
      }
      if(sp.behavior==='ambush'){
        vec.x *= 0.35; vec.y *= 0.35;
      }
      if(sp.behavior==='wander'){
        vec.x += randBetween(-0.2,0.2);
        vec.y += randBetween(-0.2,0.2);
      }
      const coverBias = sp.coverAffinity || 0;
      if(Math.abs(coverBias)>0.01){
        const best = findNearestCover(a, coverBias>0);
        if(best) {
          vec.x += (best.x - a.x)*0.02*coverBias;
          vec.y += (best.y - a.y)*0.02*coverBias;
        }
      }
      const len = Math.hypot(vec.x, vec.y) || 1;
      return { x: vec.x/len*0.4, y: vec.y/len*0.4 };
    }

    function findNearestCover(a, seekDense){
      let best=null; let bestScore = seekDense? -1: 999;
      for(let i=0;i<state.terrain.length;i+=12){
        const t = terrainTypes.find(tt=>tt.key===state.terrain[i]);
        if(!t) continue;
        const score = t.cover;
        const x = (i % state.gridW); const y = Math.floor(i/state.gridW);
        const d = Math.hypot(a.x-x, a.y-y);
        if(d>6) continue;
        if(seekDense && score>bestScore){ bestScore = score; best={x,y}; }
        if(!seekDense && score<bestScore){ bestScore = score; best={x,y}; }
      }
      return best;
    }

    function consumePlant(a, sp, hunger){
      const idx = Math.floor(a.y)*state.gridW + Math.floor(a.x);
      if(idx<0 || idx>=state.plants.length) return;
      const terrain = terrainTypes.find(t=>t.key===state.terrain[idx]);
      if(!terrain || terrain.isWater || terrain.isRock) return;
      let plant = state.plants[idx];
      if(plant<=0 || hunger<0.2) return;
      const eat = Math.min(plant, 0.08 + hunger*0.1);
      plant -= eat;
      a.satiety = clamp01(a.satiety + eat*0.7);
      a.energy = clamp01(a.energy + eat*0.2);
      state.plants[idx] = plant;
    }

    function huntPrey(a, sp, alerts){
      const target = findPrey(a, sp);
      if(!target) return;
      const d = dist(a, target);
      alerts.push({x:target.x, y:target.y});
      if(d < 0.7){
        const allies = state.animals.filter(b=>b!==a && b.diet==='carn' && dist(b,target)<2).length;
        const cover = terrainTypes.find(t=>t.key===state.terrain[Math.floor(target.y)*state.gridW + Math.floor(target.x)])?.cover || 0;
        const success = Math.random() < 0.55 + allies*0.08 - cover*0.25;
        if(success){
          a.satiety = clamp01(a.satiety + 0.7/(allies||1));
          a.energy = clamp01(a.energy + 0.4/(allies||1));
          state.animals = state.animals.filter(x => x!==target);
          state.huntEvents.push({x:target.x, y:target.y, time:performance.now()});
        }
      } else {
        a.vx += (target.x - a.x)*0.02; a.vy += (target.y - a.y)*0.02;
      }
    }

    function findPrey(a, sp){
      let best=null; let bestD=999;
      state.animals.forEach(b => {
        if(b.diet!=='herb') return;
        const tile = terrainTypes.find(t=>t.key===state.terrain[Math.floor(b.y)*state.gridW + Math.floor(b.x)]);
        const cover = tile?.cover || 0;
        const range = sp.vision * (1 - cover*0.4);
        const d = dist(a,b);
        if(d<range && d<bestD){ best=b; bestD=d; }
      });
      return best;
    }

    function tryReproduce(a, sp){
      if(a.lastBreed < sp.reproduction.interval) return;
      if(a.satiety < 0.55 || a.energy < 0.5) return;
      const idx = Math.floor(a.y)*state.gridW + Math.floor(a.x);
      const nearDen = state.dens.has(idx);
      const chance = nearDen ? 0.5 : 0.12;
      if(Math.random() < chance){
        const litter = Math.round(randBetween(sp.reproduction.litter[0], sp.reproduction.litter[1]));
        for(let i=0;i<litter;i++) state.animals.push(makeAnimal(a.species));
        a.lastBreed = 0;
        a.energy -= 0.2;
        state.reproductionEvents.push({x:a.x, y:a.y, time:performance.now()});
      }
    }

    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

    function checkEndCondition(){
      if(!extinctionModeCheckbox.checked) return;
      const animalsLeft = state.animals.length;
      const plantsLeft = state.plants.some((v,i)=>{
        const terrain = terrainTypes.find(t=>t.key===state.terrain[i]);
        if(!terrain || terrain.isWater || terrain.isRock) return false;
        return v>0.02;
      });
      if(animalsLeft===0 && !plantsLeft){
        state.running=false;
      }
    }

    function findFoodPatch(a){
      let best=null; let bestScore=0;
      for(let dy=-3; dy<=3; dy++){
        for(let dx=-3; dx<=3; dx++){
          const x = wrap(Math.floor(a.x+dx), state.gridW);
          const y = wrap(Math.floor(a.y+dy), state.gridH);
          const idx = y*state.gridW + x;
          const terrain = terrainTypes.find(t=>t.key===state.terrain[idx]);
          if(!terrain || terrain.isWater || terrain.isRock) continue;
          const score = state.plants[idx];
          if(score > bestScore){ bestScore = score; best = {x:a.x+dx, y:a.y+dy}; }
        }
      }
      return best;
    }

    canvasDebugToggle.addEventListener('click', ()=>{
      debugEnabled = !debugEnabled;
      canvasDebugToggle.setAttribute('aria-pressed', debugEnabled);
      canvasDebugToggle.textContent = debugEnabled ? '非表示' : '表示';
      updateDebugPanel(measureStage());
    });

    function initCanvas(){
      requestAnimationFrame(()=>{
        requestAnimationFrame(()=>{
          if(pInstance) return;
          pInstance = new p5(sketch, mapStage);
        });
      });
    }
    initCanvas();
  </script>
</body>
</html>
