<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bio-Sphere Manager デモ</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@latest/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@latest/dist/chart.umd.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    *{box-sizing:border-box;}
    body{
      margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      background:radial-gradient(circle at 20% 20%, rgba(90,162,247,0.08), transparent 40%), #060a0f;
      color:#e6edf3; line-height:1.5;
      font-size: clamp(16px, 1.6vw, 19px);
      letter-spacing:0.02em;
      overflow:hidden;
    }
    header{
      padding:16px 18px; border-bottom:1px solid #101826;
      background: linear-gradient(180deg, #0f1620, #0b0f14);
      position: sticky; top:0; z-index:8;
      box-shadow:0 12px 34px rgba(0,0,0,0.35);
    }
    header .title{font-size:22px; font-weight:800;}
    header .sub{font-size:13px; color:#9fb0c3; margin-top:6px;}

    #appRoot{position:relative; height:calc(100vh - 90px); overflow:hidden;}
    #p5-container{position:relative; height:100%;}
    canvas{display:block; border-radius:18px; width:100% !important; height:100% !important; box-shadow:0 18px 46px rgba(0,0,0,0.55);}    

    /* Widget system */
    .widget{position:fixed; z-index:12; border-radius:14px; border:1px solid #223247; background:rgba(12,18,26,0.94); box-shadow:0 12px 34px rgba(0,0,0,0.45); min-width:240px; pointer-events:auto; color:#dce6f3;}
    .widget-header{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 12px; background:linear-gradient(180deg, rgba(26,42,60,0.95), rgba(15,24,36,0.95)); border-bottom:1px solid #1f2a37; cursor:grab; user-select:none;}
    .widget.dragging .widget-header{cursor:grabbing;}
    .widget-title{font-weight:800; font-size:14px; letter-spacing:0.04em;}
    .widget-controls{display:flex; gap:6px; margin-left:auto;}
    .widget-controls button{padding:6px 8px; min-height:28px; border-radius:10px; border:1px solid #2a3a52; background:#132235; color:#dce6f3; cursor:pointer;}
    .widget-controls button:hover{background:#1c2e48;}
    .widget-body{padding:10px 12px; max-height:70vh; overflow:auto;}
    .widget.is-minimized .widget-body{display:none;}
    .widget.is-minimized{min-height:48px; width:260px;}
    .widget.is-maximized{width:90vw; height:90vh; max-width:92vw; max-height:92vh; box-shadow:0 16px 42px rgba(0,0,0,0.55); inset:5vh auto auto 5vw;}
    .widget.is-maximized .widget-body{max-height:calc(90vh - 70px); overflow:auto;}
    .widget.is-maximized .widget-header{cursor:default;}

    .widget-dock{position:fixed; left:12px; bottom:12px; right:12px; display:flex; justify-content:space-between; gap:12px; z-index:11; pointer-events:none;}
    .dock-col{display:flex; gap:8px; flex-wrap:wrap; pointer-events:auto;}
    .dock-chip{border-radius:12px; padding:8px 12px; border:1px solid #2a3a52; background:#0d1420; color:#c9d6e2; cursor:pointer; box-shadow:0 8px 24px rgba(0,0,0,0.35);}    

    .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #2a3a52; background:#132235; font-size:12px; color:#9fb0c3;}
    .btn{background:#132235; border:1px solid #243244; border-radius:10px; padding:10px 12px; color:#e6edf3; cursor:pointer;}
    .btn:hover{background:#1a2e46;}
    .btn.primary{background:#1b3554; border-color:#2a466b;}
    .btn.danger{background:#3a1620; border-color:#5a2430;}

    .hud-grid{display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:10px;}
    .hud-item{border:1px solid #223247; border-radius:12px; padding:8px 10px; background:rgba(17,24,38,0.9);}    
    .hud-item .label{font-size:12px; color:#9fb0c3; margin-bottom:6px; letter-spacing:0.05em;}
    .hud-item .value{font-size:20px; font-weight:800;}

    .legend-grid{display:grid; gap:10px; grid-template-columns: repeat(auto-fit, minmax(140px,1fr));}
    .legend-row{display:flex; align-items:center; gap:8px;}
    .legend-swatch{width:16px; height:16px; border-radius:4px; border:1px solid #d9e2f3;}

    .section{border:1px solid #223247; border-radius:12px; margin-top:12px; overflow:hidden;}
    .section summary{cursor:pointer; padding:12px 14px; font-weight:700; color:#c3d5eb; list-style:none; user-select:none; background:linear-gradient(90deg, rgba(34,50,71,0.4), rgba(34,50,71,0.1));}
    .section[open] summary{border-bottom:1px solid #223247;}
    .section summary::-webkit-details-marker{display:none;}
    .section .section-body{padding:14px; display:grid; gap:14px;}

    .floating-settings{position:fixed; right:18px; bottom:20px; z-index:25;}
    .fab{border-radius:999px; padding:12px 18px; font-weight:700; box-shadow:0 12px 32px rgba(0,0,0,0.45);}

    .backdrop{position:fixed; inset:0; background:rgba(8,12,18,0.72); display:none; align-items:center; justify-content:center; z-index:22; pointer-events:none;}
    .backdrop.active{display:flex; pointer-events:auto;}
    .hidden{display:none!important;}
  </style>
</head>
<body>
  <header>
    <div class="title">Bio-Sphere Manager</div>
    <div class="sub">Window Manager refresh + ecology sandbox</div>
  </header>
  <div id="appRoot">
    <div id="p5-container"></div>
  </div>

  <div class="widget" id="hudWidget" style="left:16px; top:96px; width:360px;">
    <div class="widget-header" data-widget-id="hudWidget">
      <div class="widget-title">HUD</div>
      <div class="widget-controls">
        <button data-ui-action="minimize" data-widget-id="hudWidget">—</button>
        <button data-ui-action="maximize" data-widget-id="hudWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="hud-grid">
        <div class="hud-item"><div class="label">Population</div><div class="value" id="hudPop">0</div></div>
        <div class="hud-item"><div class="label">Season</div><div class="value" id="hudSeason">Spring</div></div>
        <div class="hud-item"><div class="label">Temperature</div><div class="value" id="hudTemp">0℃</div></div>
        <div class="hud-item"><div class="label">Rain</div><div class="value" id="hudRain">0</div></div>
        <div class="hud-item"><div class="label">Score</div><div class="value" id="hudScore">0</div></div>
      </div>
    </div>
  </div>

  <div class="widget" id="summaryWidget" style="left:400px; top:96px; width:320px;">
    <div class="widget-header" data-widget-id="summaryWidget">
      <div class="widget-title">Generation Summary</div>
      <div class="widget-controls">
        <button data-ui-action="minimize" data-widget-id="summaryWidget">—</button>
        <button data-ui-action="maximize" data-widget-id="summaryWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div id="presetInfo" class="help">Preset: Temperate Forest</div>
      <div id="genSummary">No data yet.</div>
    </div>
  </div>

  <div class="widget" id="controlsWidget" style="left:16px; top:320px; width:320px;">
    <div class="widget-header" data-widget-id="controlsWidget">
      <div class="widget-title">Quick Controls</div>
      <div class="widget-controls">
        <button data-ui-action="minimize" data-widget-id="controlsWidget">—</button>
        <button data-ui-action="maximize" data-widget-id="controlsWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
        <button class="btn primary" id="startBtn">Start</button>
        <button class="btn" id="stopBtn">Stop</button>
        <button class="btn danger" id="panicBtn">Panic</button>
      </div>
      <div class="section">
        <details open>
          <summary>Overlay toggles</summary>
          <div class="section-body">
            <label><input type="checkbox" id="toggleHearts" checked /> show ♡</label>
            <label><input type="checkbox" id="toggleFlashes" checked /> show hunts</label>
          </div>
        </details>
      </div>
      <div class="section">
        <details open>
          <summary>Camera</summary>
          <div class="section-body">
            <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn" id="resetView">Reset View</button>
            </div>
          </div>
        </details>
      </div>
    </div>
  </div>

  <div class="widget" id="legendWidget" style="right:16px; top:96px; width:300px;">
    <div class="widget-header" data-widget-id="legendWidget">
      <div class="widget-title">Legend</div>
      <div class="widget-controls">
        <button data-ui-action="minimize" data-widget-id="legendWidget">—</button>
        <button data-ui-action="maximize" data-widget-id="legendWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="legend-grid" id="legendList"></div>
    </div>
  </div>

  <div class="widget" id="settingsWidget" style="right:16px; top:320px; width:360px;">
    <div class="widget-header" data-widget-id="settingsWidget">
      <div class="widget-title">Settings</div>
      <div class="widget-controls">
        <button data-ui-action="minimize" data-widget-id="settingsWidget">—</button>
        <button data-ui-action="maximize" data-widget-id="settingsWidget">▢</button>
      </div>
    </div>
    <div class="widget-body">
      <div class="section">
        <details open>
          <summary>Simulation</summary>
          <div class="section-body">
            <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn" data-preset="temperate">Temperate Forest</button>
              <button class="btn" data-preset="savanna">Savanna</button>
              <button class="btn" data-preset="wetland">Wetland</button>
            </div>
            <div class="row" style="display:flex; gap:8px; flex-wrap:wrap;">
              <label><input type="checkbox" id="modeExtinction" /> run until all extinct</label>
            </div>
            <div class="section" style="margin-top:8px;">
              <details open>
                <summary>Behavior mode (per species)</summary>
                <div class="section-body" id="behaviorControls" style="display:grid; gap:8px;"></div>
              </details>
            </div>
          </div>
        </details>
      </div>
    </div>
  </div>

  <div class="widget-dock">
    <div class="dock-col" id="dockLeft"></div>
    <div class="dock-col" id="dockRight"></div>
  </div>

  <div class="backdrop" id="modalBackdrop"></div>

  <script>
    /* Window manager */
    const widgetManager = (() => {
      const widgets = new Map();
      const dockLeft = document.getElementById('dockLeft');
      const dockRight = document.getElementById('dockRight');
      let dragging = null;

      const register = (id) => {
        const el = document.getElementById(id);
        if(!el) return;
        widgets.set(id, { el, docked:false });
      };

      const minimize = (id) => {
        const entry = widgets.get(id); if(!entry) return;
        const { el } = entry;
        if(el.classList.contains('is-minimized')) return restoreFromDock(id);
        el.classList.add('is-minimized');
        const dockTarget = el.classList.contains('dock-right') ? dockRight : dockLeft;
        const chip = document.createElement('button');
        chip.className = 'dock-chip';
        chip.textContent = el.querySelector('.widget-title').textContent;
        chip.dataset.widgetId = id;
        dockTarget.appendChild(chip);
        entry.dockedChip = chip;
        entry.prevStyle = { left: el.style.left, top: el.style.top };
        el.style.left = '-9999px'; el.style.top = '-9999px';
      };

      const restoreFromDock = (id) => {
        const entry = widgets.get(id); if(!entry) return;
        const { el, dockedChip, prevStyle } = entry;
        el.classList.remove('is-minimized');
        if(dockedChip?.parentNode) dockedChip.parentNode.removeChild(dockedChip);
        if(prevStyle){ el.style.left = prevStyle.left; el.style.top = prevStyle.top; }
        clampToViewport(el);
      };

      const maximize = (id) => {
        const entry = widgets.get(id); if(!entry) return;
        const { el } = entry;
        if(el.classList.contains('is-maximized')) return restoreSize(id);
        entry.restoreRect = {
          left: el.style.left,
          top: el.style.top,
          width: el.style.width,
          height: el.style.height,
        };
        el.classList.add('is-maximized');
      };

      const restoreSize = (id) => {
        const entry = widgets.get(id); if(!entry) return;
        const { el, restoreRect } = entry;
        el.classList.remove('is-maximized');
        if(restoreRect){
          el.style.left = restoreRect.left;
          el.style.top = restoreRect.top;
          el.style.width = restoreRect.width;
          el.style.height = restoreRect.height;
        }
        clampToViewport(el);
      };

      const clampToViewport = (el) => {
        const rect = el.getBoundingClientRect();
        const vw = window.innerWidth; const vh = window.innerHeight;
        let left = rect.left; let top = rect.top;
        left = Math.min(Math.max(left, 8), vw - rect.width - 8);
        top = Math.min(Math.max(top, 8), vh - rect.height - 8);
        el.style.left = `${left}px`; el.style.top = `${top}px`;
      };

      const startDrag = (e) => {
        const header = e.target.closest('.widget-header');
        if(!header) return;
        const id = header.dataset.widgetId; const entry = widgets.get(id); if(!entry) return;
        const el = entry.el;
        if(el.classList.contains('is-maximized')) return;
        dragging = { id, startX:e.clientX, startY:e.clientY, rect: el.getBoundingClientRect() };
        document.body.classList.add('is-widget-dragging');
        header.setPointerCapture(e.pointerId);
      };

      const doDrag = (e) => {
        if(!dragging) return;
        const entry = widgets.get(dragging.id); if(!entry) return;
        const el = entry.el;
        const dx = e.clientX - dragging.startX;
        const dy = e.clientY - dragging.startY;
        const left = dragging.rect.left + dx;
        const top = dragging.rect.top + dy;
        el.style.left = `${left}px`;
        el.style.top = `${top}px`;
      };

      const endDrag = (e) => {
        if(!dragging) return;
        const entry = widgets.get(dragging.id); if(entry) clampToViewport(entry.el);
        dragging = null;
        document.body.classList.remove('is-widget-dragging');
      };

      document.addEventListener('click', (e) => {
        const btn = e.target.closest('[data-ui-action]');
        if(!btn) return;
        const id = btn.dataset.widgetId;
        const action = btn.dataset.uiAction;
        if(action === 'minimize') minimize(id);
        if(action === 'maximize') maximize(id);
        if(action === 'close') restoreFromDock(id);
      });

      document.addEventListener('click', (e) => {
        const chip = e.target.closest('.dock-chip');
        if(!chip) return;
        restoreFromDock(chip.dataset.widgetId);
      });

      document.addEventListener('pointerdown', startDrag);
      document.addEventListener('pointermove', doDrag);
      document.addEventListener('pointerup', endDrag);

      window.addEventListener('resize', () => widgets.forEach(({el}) => clampToViewport(el)));

      return { register, minimize, maximize, restoreSize, restoreFromDock, clampToViewport };
    })();

    ['hudWidget','summaryWidget','controlsWidget','legendWidget','settingsWidget'].forEach(widgetManager.register);

    /* Simulation */
    const legendList = document.getElementById('legendList');
    const presetButtons = document.querySelectorAll('[data-preset]');
    const toggleHearts = document.getElementById('toggleHearts');
    const toggleFlashes = document.getElementById('toggleFlashes');
    const extinctionModeCheckbox = document.getElementById('modeExtinction');
    const behaviorControls = document.getElementById('behaviorControls');

    const terrainTypes = [
      { key:'grass', name:'Grassland', color:'#1f6f3f', texture:'#2b8a4f', plantK:0.65, cover:0.1, isWater:false, isRock:false },
      { key:'forest', name:'Forest', color:'#19341f', texture:'#225028', plantK:0.8, cover:0.4, isWater:false, isRock:false },
      { key:'shrub', name:'Shrubland', color:'#245c3c', texture:'#2f7a4c', plantK:0.7, cover:0.25, isWater:false, isRock:false },
      { key:'rock', name:'Rock', color:'#545b63', texture:'#737b84', plantK:0, cover:0.05, isWater:false, isRock:true },
      { key:'water', name:'Water', color:'#1b3b62', texture:'#27517f', plantK:0, cover:0, isWater:true, isRock:false },
      { key:'wetland', name:'Wetland', color:'#1f4f58', texture:'#2f7a88', plantK:0.9, cover:0.18, isWater:false, isRock:false },
      { key:'sand', name:'Sand', color:'#7a623c', texture:'#8b754f', plantK:0.3, cover:0.05, isWater:false, isRock:false },
    ];

    const speciesLibrary = {
      deer:{ name:'Deer-like', diet:'herb', color:'#9be070', outline:'#0d190a', inner:'#d7f7b2', speed:0.6, sociality:0.5, behavior:'herd', metabolism:0.002, satietyDecay:0.003, reproduction: {interval:1400, litter:[1,2]}, vision:4, coverAffinity:0.2 },
      wolf:{ name:'Wolf-like', diet:'carn', color:'#ff9f70', outline:'#3a1205', inner:'#ffc9a6', speed:0.8, sociality:0.7, behavior:'pack', metabolism:0.0022, satietyDecay:0.003, reproduction: {interval:1800, litter:[2,3]}, vision:5, coverAffinity:-0.1 },
      zebra:{ name:'Zebra-like', diet:'herb', color:'#d8f0ff', outline:'#101820', inner:'#6dc6ff', speed:0.75, sociality:0.7, behavior:'herd', metabolism:0.002, satietyDecay:0.003, reproduction: {interval:1600, litter:[1,1]}, vision:4, coverAffinity:0 },
      lion:{ name:'Lion-like', diet:'carn', color:'#f1c56a', outline:'#4e2c05', inner:'#ffe2a6', speed:0.7, sociality:0.6, behavior:'pack', metabolism:0.0024, satietyDecay:0.003, reproduction:{interval:1900, litter:[2,3]}, vision:5, coverAffinity:-0.05 },
      capybara:{ name:'Wetland herb', diet:'herb', color:'#cdb18a', outline:'#302215', inner:'#f3e3c8', speed:0.45, sociality:0.4, behavior:'den', metabolism:0.0018, satietyDecay:0.0025, reproduction:{interval:1500, litter:[2,4]}, vision:3, coverAffinity:0.25 },
      otter:{ name:'Otter-like', diet:'carn', color:'#9cc4ff', outline:'#0c1d32', inner:'#d7e7ff', speed:0.6, sociality:0.5, behavior:'ambush', metabolism:0.0021, satietyDecay:0.0028, reproduction:{interval:1600, litter:[1,2]}, vision:4, coverAffinity:0.15 }
    };

    const presets = {
      temperate: {
        label:'温帯森林',
        description:'Four seasons, browse-rich understory, wolves pack up in late winter.',
        climate:{ temp: [10,18,12,2], rain:[0.22,0.32,0.25,0.16] },
        animals:[
          { species:'deer', count:32 },
          { species:'wolf', count:12 },
        ],
        terrain: { forest:0.34, shrub:0.18, wetland:0.08, water:0.08, rock:0.08, sand:0.02 }
      },
      savanna: {
        label:'サバンナ',
        description:'Long dry season, explosive wet growth; lions cooperate around water holes.',
        climate:{ temp:[24,31,27,19], rain:[0.1,0.32,0.07,0.04] },
        animals:[
          { species:'zebra', count:34 },
          { species:'lion', count:14 },
        ],
        terrain: { grass:0.34, shrub:0.2, sand:0.14, water:0.08, rock:0.05, wetland:0.05 }
      },
      wetland: {
        label:'湿地',
        description:'Expansive marsh with rocky dens; otters ambush along reeds.',
        climate:{ temp:[18,24,15,9], rain:[0.32,0.44,0.28,0.22] },
        animals:[
          { species:'capybara', count:28 },
          { species:'otter', count:12 },
        ],
        terrain: { wetland:0.34, water:0.18, forest:0.16, rock:0.09, grass:0.1, shrub:0.05 }
      }
    };

    const state = {
      running:false,
      season:0,
      temp:12,
      rain:0,
      score:0,
      animals:[],
      plants:[],
      terrain:[],
      dens: new Set(),
      reproductionEvents:[],
      huntEvents:[],
      view:{ scale:1, offsetX:0, offsetY:0 },
      gridW:72,
      gridH:44,
      tile:18,
      climate: presets.temperate.climate,
      endAllExtinct:false,
    };

    const legendEntries = [
      ...terrainTypes.map(t=>({label:t.name, color:t.color})),
      { label:'Herbivore', color:'#9be070' },
      { label:'Carnivore', color:'#ff9f70' },
      { label:'Den', color:'#f5d97a' }
    ];

    function renderLegend(){
      legendList.innerHTML = '';
      legendEntries.forEach(t => {
        const row = document.createElement('div');
        row.className = 'legend-row';
        row.innerHTML = `<span class="legend-swatch" style="background:${t.color}"></span><span>${t.label}</span>`;
        legendList.appendChild(row);
      });
    }
    renderLegend();

    /* Core sim helpers */
    const clamp01 = (v) => Math.min(1, Math.max(0, v));
    const randBetween = (min,max) => min + Math.random()*(max-min);
    const wrap = (v, max) => (v + max) % max;

    function createTerrain(weights){
      const cumulative = [];
      let sum = 0;
      const keys = Object.keys(weights);
      keys.forEach(k=>{ sum += weights[k]; cumulative.push({key:k, end:sum}); });
      const total = sum || 1;
      const arr=[];
      for(let i=0;i<state.gridW*state.gridH;i++){
        const r = Math.random()*total;
        const found = cumulative.find(c=>r<=c.end) || cumulative[cumulative.length-1];
        arr.push(found.key);
      }
      return arr;
    }

    function setupDens(){
      state.dens.clear();
      for(let i=0;i<state.terrain.length;i++){
        const t = terrainTypes.find(tt=>tt.key===state.terrain[i]);
        if(!t || t.isWater || t.isRock) continue;
        if(t.key==='rock' || t.key==='forest'){
          if(Math.random()<0.06) state.dens.add(i);
        } else if(t.key==='shrub' && Math.random()<0.04){
          state.dens.add(i);
        }
      }
    }

    function initPlants(){
      state.plants = state.terrain.map(t => {
        const terrain = terrainTypes.find(tt=>tt.key===t);
        if(terrain.isWater || terrain.isRock) return 0;
        return randBetween(0.2, terrain.plantK);
      });
    }

    function spawnAnimals(animalDefs){
      state.animals = [];
      animalDefs.forEach(def => {
        const sp = speciesLibrary[def.species];
        if(!sp) return;
        for(let i=0;i<def.count;i++){
          state.animals.push(makeAnimal(def.species));
        }
      });
    }

    function makeAnimal(speciesKey){
      const sp = speciesLibrary[speciesKey];
      return {
        id:crypto.randomUUID(),
        species: speciesKey,
        diet: sp.diet,
        x: Math.random()*state.gridW,
        y: Math.random()*state.gridH,
        vx: randBetween(-0.2,0.2),
        vy: randBetween(-0.2,0.2),
        energy: 1,
        satiety: 0.6,
        age: 0,
        lastBreed:0,
      };
    }

    function applyPreset(key){
      const preset = presets[key];
      if(!preset) return;
      state.climate = preset.climate;
      state.season = 0; state.score = 0; state.temp = preset.climate.temp[0]; state.rain = preset.climate.rain[0];
      state.terrain = createTerrain(preset.terrain);
      setupDens();
      initPlants();
      spawnAnimals(preset.animals);
      renderSummary();
      updateHUD();
      const note = preset.description || '';
      document.getElementById('presetInfo').textContent = `Preset: ${preset.label}${note ? ' — ' + note : ''}`;
    }

    presetButtons.forEach(btn => btn.addEventListener('click', ()=>{
      applyPreset(btn.dataset.preset);
      state.running = true;
    }));

    function renderBehaviorControls(){
      behaviorControls.innerHTML = '';
      Object.entries(speciesLibrary).forEach(([key, sp]) => {
        const row = document.createElement('div');
        row.style.display = 'grid';
        row.style.gridTemplateColumns = '140px 1fr';
        row.style.alignItems = 'center';
        const label = document.createElement('div');
        label.textContent = sp.name;
        const select = document.createElement('select');
        ['herd','pack','ambush','den','wander'].forEach(mode => {
          const opt = document.createElement('option');
          opt.value = mode; opt.textContent = mode;
          if(sp.behavior===mode) opt.selected = true;
          select.appendChild(opt);
        });
        select.addEventListener('change', ()=>{
          speciesLibrary[key].behavior = select.value;
        });
        row.appendChild(label); row.appendChild(select);
        behaviorControls.appendChild(row);
      });
    }
    renderBehaviorControls();

    const hudEls = {
      pop: document.getElementById('hudPop'),
      season: document.getElementById('hudSeason'),
      temp: document.getElementById('hudTemp'),
      rain: document.getElementById('hudRain'),
      score: document.getElementById('hudScore'),
    };

    function updateHUD(){
      hudEls.pop.textContent = state.animals.length;
      hudEls.season.textContent = ['Spring','Summer','Autumn','Winter'][state.season%4];
      hudEls.temp.textContent = `${state.temp.toFixed(1)}℃`;
      hudEls.rain.textContent = state.rain.toFixed(2);
      hudEls.score.textContent = state.score.toFixed(0);
    }

    function renderSummary(){
      const counts = {};
      state.animals.forEach(a => { counts[a.species] = (counts[a.species]||0)+1; });
      const lines = Object.entries(counts).map(([k,v])=>`${speciesLibrary[k]?.name||k}: ${v}`);
      document.getElementById('genSummary').textContent = lines.join(' / ') || 'No data';
    }

    /* Simulation */
    let sketch = (p) => {
      let pan = { active:false, startX:0, startY:0, originX:0, originY:0 };

      p.setup = () => {
        const wrap = document.getElementById('p5-container');
        const cnv = p.createCanvas(wrap.clientWidth, wrap.clientHeight);
        cnv.parent('p5-container');
        applyPreset('temperate');
      };

      p.windowResized = () => {
        const wrap = document.getElementById('p5-container');
        p.resizeCanvas(wrap.clientWidth, wrap.clientHeight);
      };

      p.draw = () => {
        p.background('#05080f');
        drawTerrain(p);
        drawPlants(p);
        drawDens(p);
        drawAnimals(p);
        drawEvents(p);
        if(state.running) stepSim();
      };

      function worldToScreen(x,y){
        return {
          x: x*state.tile*state.view.scale + state.view.offsetX,
          y: y*state.tile*state.view.scale + state.view.offsetY
        };
      }

      function drawTerrain(p){
        for(let y=0;y<state.gridH;y++){
          for(let x=0;x<state.gridW;x++){
            const idx = y*state.gridW+x;
            const tKey = state.terrain[idx];
            const terrain = terrainTypes.find(t=>t.key===tKey) || terrainTypes[0];
            const pos = worldToScreen(x,y);
            const size = state.tile*state.view.scale;
            p.noStroke();
            p.fill(terrain.color);
            p.rect(pos.x, pos.y, size, size);
            p.stroke(terrain.texture);
            p.strokeWeight(1);
            if(tKey==='forest'){
              p.line(pos.x+size*0.3, pos.y, pos.x+size*0.7, pos.y+size);
              p.line(pos.x, pos.y+size*0.4, pos.x+size, pos.y+size*0.6);
            } else if(tKey==='water'){
              p.noFill();
              p.curve(pos.x, pos.y+size*0.2, pos.x+size*0.2, pos.y+size*0.4, pos.x+size*0.6, pos.y+size*0.6, pos.x+size, pos.y+size*0.8);
            } else if(tKey==='rock'){
              p.fill(terrain.texture); p.noStroke();
              p.triangle(pos.x+size*0.2,pos.y+size*0.8,pos.x+size*0.5,pos.y+size*0.2,pos.x+size*0.8,pos.y+size*0.9);
            } else if(tKey==='wetland'){
              p.noFill(); p.stroke(terrain.texture);
              p.ellipse(pos.x+size*0.4,pos.y+size*0.6,size*0.4,size*0.25);
            } else if(tKey==='sand'){
              p.noFill(); p.stroke(terrain.texture);
              p.line(pos.x+size*0.2,pos.y+size*0.7,pos.x+size*0.8,pos.y+size*0.65);
            } else if(tKey==='shrub'){
              p.noStroke(); p.fill(terrain.texture);
              p.circle(pos.x+size*0.3,pos.y+size*0.4,size*0.2);
              p.circle(pos.x+size*0.6,pos.y+size*0.5,size*0.25);
            }
          }
        }
      }

      function drawPlants(p){
        p.noStroke();
        state.plants.forEach((v,idx)=>{
          if(v<=0.01) return;
          const x = idx % state.gridW;
          const y = Math.floor(idx / state.gridW);
          const pos = worldToScreen(x,y);
          const size = state.tile*state.view.scale;
          p.fill(100,200,120, clamp01(v)*180 + 40);
          p.circle(pos.x+size/2, pos.y+size/2, Math.max(4, size*0.4*v));
        });
      }

      function drawDens(p){
        p.noStroke();
        state.dens.forEach(idx => {
          const x = idx % state.gridW; const y = Math.floor(idx/state.gridW);
          const pos = worldToScreen(x,y);
          const size = state.tile*state.view.scale;
          p.fill('#f5d97a');
          p.rect(pos.x+size*0.28,pos.y+size*0.28,size*0.44,size*0.44,4);
        });
      }

      function drawAnimals(p){
        state.animals.forEach(a=>{
          const pos = worldToScreen(a.x,a.y);
          const size = state.tile*state.view.scale;
          const sp = speciesLibrary[a.species];
          if(!sp) return;
          p.stroke(sp.outline); p.strokeWeight(1.6); p.fill(sp.color);
          if(sp.diet==='herb'){
            p.circle(pos.x, pos.y, size*0.72);
            p.fill(sp.inner); p.noStroke();
            p.circle(pos.x, pos.y, size*0.3);
          } else {
            p.triangle(pos.x-size*0.4,pos.y+size*0.4,pos.x+size*0.4,pos.y+size*0.4,pos.x,pos.y-size*0.5);
            p.fill(sp.inner); p.noStroke();
            p.triangle(pos.x-size*0.18,pos.y+size*0.18,pos.x+size*0.18,pos.y+size*0.18,pos.x,pos.y-size*0.24);
          }
        });
      }

      function drawEvents(p){
        const now = performance.now();
        state.reproductionEvents = state.reproductionEvents.filter(ev => now-ev.time < 900);
        state.huntEvents = state.huntEvents.filter(ev => now-ev.time < 480);

        if(toggleHearts.checked){
          state.reproductionEvents.forEach(ev => {
            const t = (now-ev.time)/900;
            const pos = worldToScreen(ev.x, ev.y);
            p.noStroke(); p.fill(`rgba(255,120,200,${1-t})`);
            p.textSize(state.tile*state.view.scale*0.8);
            p.text('♡', pos.x, pos.y);
          });
        }
        if(toggleFlashes.checked){
          state.huntEvents.forEach(ev => {
            const t = (now-ev.time)/480;
            const pos = worldToScreen(ev.x, ev.y);
            p.noFill(); p.stroke(`rgba(255,180,80,${1-t})`); p.strokeWeight(3);
            const r = state.tile*state.view.scale*(0.6 + t*0.6);
            p.circle(pos.x, pos.y, r);
          });
        }
      }

      p.mouseWheel = (event) => {
        const factor = event.delta > 0 ? 0.92 : 1.08;
        state.view.scale = Math.min(Math.max(state.view.scale * factor, 0.6), 2.6);
      };

      p.mousePressed = () => {
        if(p.mouseButton === p.CENTER || (p.mouseButton === p.LEFT && p.keyIsDown(32))){
          pan.active = true; pan.startX = p.mouseX; pan.startY = p.mouseY; pan.originX = state.view.offsetX; pan.originY = state.view.offsetY;
        }
      };
      p.mouseDragged = () => {
        if(pan.active){
          state.view.offsetX = pan.originX + (p.mouseX - pan.startX);
          state.view.offsetY = pan.originY + (p.mouseY - pan.startY);
        }
      };
      p.mouseReleased = () => { pan.active=false; };

      document.getElementById('resetView').addEventListener('click', ()=>{
        state.view = { scale:1, offsetX:0, offsetY:0 };
      });
      document.getElementById('startBtn').addEventListener('click', ()=> state.running=true);
      document.getElementById('stopBtn').addEventListener('click', ()=> state.running=false);
      document.getElementById('panicBtn').addEventListener('click', ()=>{
        document.querySelectorAll('.backdrop').forEach(el=>el.classList.remove('active'));
        document.querySelectorAll('.widget').forEach(el=>{
          el.classList.remove('is-maximized');
          widgetManager.clampToViewport(el);
        });
        state.view = { scale:1, offsetX:0, offsetY:0 };
      });
    };

    function stepSim(){
      const stepsPerFrame = 2;
      for(let s=0;s<stepsPerFrame;s++){
        updateClimate();
        growPlants();
        updateAnimals();
        checkEndCondition();
      }
      updateHUD();
      renderSummary();
    }

    function updateClimate(){
      const seasonLength = 2200;
      state.score += 0.05;
      state.temp += (state.climate.temp[state.season%4] - state.temp) * 0.002;
      state.rain += (state.climate.rain[state.season%4] - state.rain) * 0.002;
      state.score = Math.max(0, state.score);
      if(state.score > seasonLength){
        state.season++; state.score = 0;
      }
    }

    function growPlants(){
      state.plants = state.plants.map((v,i)=>{
        const terrain = terrainTypes.find(t=>t.key===state.terrain[i]);
        if(!terrain || terrain.isWater || terrain.isRock) return 0;
        const growth = 0.001 + state.rain*0.002;
        const K = terrain.plantK;
        return clamp01(v + growth*v*(K - v));
      });
    }

    function updateAnimals(){
      const preyIndex = new Map();
      state.animals.forEach((a,i)=>{ if(a.diet==='herb') preyIndex.set(a.id, i); });
      const alerts = [];

      state.animals.forEach(a => {
        const sp = speciesLibrary[a.species];
        if(!sp) return;
        const hunger = 1 - a.satiety;
        const satiatedBrake = a.satiety>0.8 ? 0.35 : 1;
        const speed = (sp.speed + hunger*0.3) * satiatedBrake;
        if(Math.random() < speed){
          const dir = chooseDirection(a, sp, alerts);
          a.vx = dir.x; a.vy = dir.y;
          a.x = wrap(a.x + a.vx, state.gridW);
          a.y = wrap(a.y + a.vy, state.gridH);
        }
        a.satiety = clamp01(a.satiety - sp.satietyDecay);
        a.energy = clamp01(a.energy - sp.metabolism + a.satiety*0.0004);
        a.age += 1;
        a.lastBreed += 1;

        if(a.diet==='herb') consumePlant(a, sp, hunger);
        else huntPrey(a, sp, alerts);

        tryReproduce(a, sp);
      });

      state.animals = state.animals.filter(a => a.energy>0 && a.age<8000);
    }

    function chooseDirection(a, sp, alerts){
      let vec = {x: randBetween(-0.3,0.3), y: randBetween(-0.3,0.3)};
      const neighbors = state.animals.filter(b => b !== a && b.diet===a.diet && dist(a,b)<3);
      if(sp.behavior==='herd' && neighbors.length){
        const cohesion = neighbors.reduce((acc,b)=>({x:acc.x+(b.x-a.x), y:acc.y+(b.y-a.y)}), {x:0,y:0});
        vec.x += cohesion.x/neighbors.length * 0.05;
        vec.y += cohesion.y/neighbors.length * 0.05;
      }
      if(neighbors.length){
        const separation = neighbors.reduce((acc,b)=>{
          const d = dist(a,b)+0.01;
          return {x: acc.x - (b.x-a.x)/(d*d), y: acc.y - (b.y-a.y)/(d*d)};
        }, {x:0,y:0});
        vec.x += separation.x * 0.08;
        vec.y += separation.y * 0.08;
      }
      if(sp.diet==='herb'){
        const food = findFoodPatch(a);
        if(food){
          vec.x += (food.x - a.x)*0.04;
          vec.y += (food.y - a.y)*0.04;
        }
      }
      if(sp.behavior==='pack' && a.diet==='carn' && alerts.length){
        const signal = alerts.reduce((acc,al)=>({x:acc.x+al.x-a.x, y:acc.y+al.y-a.y}), {x:0,y:0});
        vec.x += signal.x/alerts.length * 0.03;
        vec.y += signal.y/alerts.length * 0.03;
      }
      if(sp.behavior==='ambush'){
        vec.x *= 0.35; vec.y *= 0.35;
      }
      if(sp.behavior==='wander'){
        vec.x += randBetween(-0.2,0.2);
        vec.y += randBetween(-0.2,0.2);
      }
      const coverBias = sp.coverAffinity || 0;
      if(Math.abs(coverBias)>0.01){
        const best = findNearestCover(a, coverBias>0);
        if(best) {
          vec.x += (best.x - a.x)*0.02*coverBias;
          vec.y += (best.y - a.y)*0.02*coverBias;
        }
      }
      const len = Math.hypot(vec.x, vec.y) || 1;
      return { x: vec.x/len*0.4, y: vec.y/len*0.4 };
    }

    function findNearestCover(a, seekDense){
      let best=null; let bestScore = seekDense? -1: 999;
      for(let i=0;i<state.terrain.length;i+=12){
        const t = terrainTypes.find(tt=>tt.key===state.terrain[i]);
        if(!t) continue;
        const score = t.cover;
        const x = (i % state.gridW); const y = Math.floor(i/state.gridW);
        const d = Math.hypot(a.x-x, a.y-y);
        if(d>6) continue;
        if(seekDense && score>bestScore){ bestScore = score; best={x,y}; }
        if(!seekDense && score<bestScore){ bestScore = score; best={x,y}; }
      }
      return best;
    }

    function consumePlant(a, sp, hunger){
      const idx = Math.floor(a.y)*state.gridW + Math.floor(a.x);
      if(idx<0 || idx>=state.plants.length) return;
      const terrain = terrainTypes.find(t=>t.key===state.terrain[idx]);
      if(!terrain || terrain.isWater || terrain.isRock) return;
      let plant = state.plants[idx];
      if(plant<=0 || hunger<0.2) return;
      const eat = Math.min(plant, 0.08 + hunger*0.1);
      plant -= eat;
      a.satiety = clamp01(a.satiety + eat*0.7);
      a.energy = clamp01(a.energy + eat*0.2);
      state.plants[idx] = plant;
    }

    function huntPrey(a, sp, alerts){
      const target = findPrey(a, sp);
      if(!target) return;
      const d = dist(a, target);
      alerts.push({x:target.x, y:target.y});
      if(d < 0.7){
        const allies = state.animals.filter(b=>b!==a && b.diet==='carn' && dist(b,target)<2).length;
        const cover = terrainTypes.find(t=>t.key===state.terrain[Math.floor(target.y)*state.gridW + Math.floor(target.x)])?.cover || 0;
        const success = Math.random() < 0.55 + allies*0.08 - cover*0.25;
        if(success){
          a.satiety = clamp01(a.satiety + 0.7/(allies||1));
          a.energy = clamp01(a.energy + 0.4/(allies||1));
          state.animals = state.animals.filter(x => x!==target);
          state.huntEvents.push({x:target.x, y:target.y, time:performance.now()});
        }
      } else {
        a.vx += (target.x - a.x)*0.02; a.vy += (target.y - a.y)*0.02;
      }
    }

    function findPrey(a, sp){
      let best=null; let bestD=999;
      state.animals.forEach(b => {
        if(b.diet!=='herb') return;
        const tile = terrainTypes.find(t=>t.key===state.terrain[Math.floor(b.y)*state.gridW + Math.floor(b.x)]);
        const cover = tile?.cover || 0;
        const range = sp.vision * (1 - cover*0.4);
        const d = dist(a,b);
        if(d<range && d<bestD){ best=b; bestD=d; }
      });
      return best;
    }

    function tryReproduce(a, sp){
      if(a.lastBreed < sp.reproduction.interval) return;
      if(a.satiety < 0.55 || a.energy < 0.5) return;
      const idx = Math.floor(a.y)*state.gridW + Math.floor(a.x);
      const nearDen = state.dens.has(idx);
      const chance = nearDen ? 0.5 : 0.12;
      if(Math.random() < chance){
        const litter = Math.round(randBetween(sp.reproduction.litter[0], sp.reproduction.litter[1]));
        for(let i=0;i<litter;i++) state.animals.push(makeAnimal(a.species));
        a.lastBreed = 0;
        a.energy -= 0.2;
        state.reproductionEvents.push({x:a.x, y:a.y, time:performance.now()});
      }
    }

    function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }

    function checkEndCondition(){
      if(!extinctionModeCheckbox.checked) return;
      const animalsLeft = state.animals.length;
      const plantsLeft = state.plants.some((v,i)=>{
        const terrain = terrainTypes.find(t=>t.key===state.terrain[i]);
        if(!terrain || terrain.isWater || terrain.isRock) return false;
        return v>0.02;
      });
      if(animalsLeft===0 && !plantsLeft){
        state.running=false;
      }
    }

    function findFoodPatch(a){
      let best=null; let bestScore=0;
      for(let dy=-3; dy<=3; dy++){
        for(let dx=-3; dx<=3; dx++){
          const x = wrap(Math.floor(a.x+dx), state.gridW);
          const y = wrap(Math.floor(a.y+dy), state.gridH);
          const idx = y*state.gridW + x;
          const terrain = terrainTypes.find(t=>t.key===state.terrain[idx]);
          if(!terrain || terrain.isWater || terrain.isRock) continue;
          const score = state.plants[idx];
          if(score > bestScore){ bestScore = score; best = {x:a.x+dx, y:a.y+dy}; }
        }
      }
      return best;
    }

    new p5(sketch);
  </script>
</body>
</html>
