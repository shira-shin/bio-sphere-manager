<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bio-Sphere Manager デモ</title>

  <!-- CDN：p5.js（描画） / Chart.js（グラフ） -->
  <script src="https://cdn.jsdelivr.net/npm/p5@latest/lib/p5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@latest/dist/chart.umd.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
      background:#0b0f14; color:#e6edf3; line-height:1.5;
      font-size: clamp(16px, 1.6vw, 19px);
      letter-spacing:0.02em;
    }
    header{
      padding:16px 18px; border-bottom:1px solid #17202b;
      background: linear-gradient(180deg, #0f1620, #0b0f14);
      position: sticky; top:0; z-index:10;
    }
    header .title{font-size:22px; font-weight:800;}
    header .sub{font-size:13px; color:#9fb0c3; margin-top:6px;}
    .layout{display:none;}
    .card{
      border:1px solid #1f2a37; border-radius:16px; background:#0f1620;
      box-shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    .card h2{margin:0; font-size:15px; color:#9fb0c3; font-weight:700; padding:16px 16px 0; letter-spacing:0.2px;}
    .pad{padding:16px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    button{
      background:#132235; color:#e6edf3; border:1px solid #243244;
      border-radius:10px; padding:10px 12px; cursor:pointer; min-height:34px;
    }
    button:hover{background:#162a42;}
    button.primary{background:#1b3554; border-color:#2a466b;}
    button.danger{background:#3a1620; border-color:#5a2430;}
    input[type="number"], input[type="text"], select{
      width: 170px; padding:9px 10px; border-radius:10px;
      border:1px solid #243244; background:#0b1220; color:#e6edf3; min-height:34px;
    }
    input[type="range"]{accent-color:#5aa2f7;}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center;}
    .kv .label{color:#9fb0c3; font-size:12px;}
    .kv .value{font-variant-numeric: tabular-nums;}
    .grid2{display:grid; grid-template-columns: 1fr 1fr; gap:12px;}
    .ctrl{
      display:grid; grid-template-columns: 1fr auto; gap:12px;
      align-items:center; margin-top:6px;
    }
    .ctrl label{font-size:13px; color:#c3d5eb;}
    .ctrl input[type="range"]{width: 260px;}
    #p5-container{position:relative; min-height:68vh; min-width:100%;}
    canvas{display:block; border-radius:16px; width:100%; height:auto; box-shadow:0 14px 38px rgba(0,0,0,0.45);}
    .note{font-size:12px; color:#9fb0c3; line-height:1.6;}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;}
    .section{
      border:1px solid #223247; border-radius:12px; margin-top:12px; overflow:hidden;
    }
    .section summary{
      cursor:pointer; padding:12px 14px; font-weight:700; color:#c3d5eb; list-style:none; user-select:none;
      background:linear-gradient(90deg, rgba(34,50,71,0.4), rgba(34,50,71,0.1));
    }
    .section[open] summary{border-bottom:1px solid #223247;}
    .section summary::-webkit-details-marker{display:none;}
    .section .section-body{padding:14px; display:grid; gap:14px;}
    .help{font-size:11px; color:#7ea0c4;}
    .preset-row{display:flex; gap:10px; align-items:flex-end; flex-wrap:wrap;}
    .badge-warning{color:#f5d97a; background:#4a3810; border:1px solid #8f6d1f; padding:2px 6px; border-radius:8px; font-size:11px;}
    .canvas-wrap{position:relative; border-radius:18px; padding:12px; background:radial-gradient(circle at 30% 20%, rgba(70,120,200,0.08), transparent 42%), linear-gradient(180deg, rgba(16,24,36,0.9), rgba(8,12,18,0.96)); box-shadow:inset 0 0 0 1px rgba(255,255,255,0.02), 0 16px 46px rgba(0,0,0,0.55); min-height:72vh;}
    .canvas-hud{position:absolute; inset:12px auto auto 12px; z-index:8; min-width:240px; max-width:360px; background:rgba(8,12,18,0.78); backdrop-filter: blur(8px); border:1px solid #223247; border-radius:14px; padding:10px 12px; box-shadow:0 12px 34px rgba(0,0,0,0.45); display:grid; gap:8px; cursor:grab;}
    .canvas-hud.dragging{cursor:grabbing;}
    .canvas-hud.collapsed .hud-grid,.canvas-hud.collapsed .hud-top{display:none;}
    .canvas-hud.collapsed{min-width:180px;}
    .hud-top{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between;}
    .hud-status{display:grid; gap:4px;}
    .hud-status .label{font-size:12px; color:#9fb0c3;}
    .hud-pill{padding:8px 12px; border-radius:999px; border:1px solid #2a3a52; font-weight:800; background:#132235; min-width:120px; text-align:center; letter-spacing:0.05em;}
    .hud-meta{font-size:13px; color:#c3d5eb; font-variant-numeric: tabular-nums;}
    .hud-grid{display:grid; grid-template-columns: repeat(auto-fit, minmax(140px,1fr)); gap:10px;}
    .hud-item{border:1px solid #223247; border-radius:12px; padding:10px 12px; background:rgba(17,24,38,0.9);}
    .hud-item .label{font-size:12px; color:#9fb0c3; margin-bottom:6px; letter-spacing:0.05em;}
    .hud-item .value{font-size:24px; font-weight:800; font-variant-numeric: tabular-nums; line-height:1.2;}
    .kpi-grid{display:grid; grid-template-columns: repeat(auto-fit, minmax(120px,1fr)); gap:8px;}
    .kpi-item{border:1px solid #223247; border-radius:12px; padding:10px; background:#111826; display:grid; gap:6px;}
    .kpi-item .value{font-size:22px; font-weight:800;}
    .tabs{display:flex; gap:8px; border-bottom:1px solid #1f2a37; padding:0 4px 8px; margin-bottom:8px; flex-wrap:wrap;}
    .tab-btn{padding:8px 12px; border-radius:10px; border:1px solid #1f2a37; background:#0f1a2a; color:#c9d6e2; cursor:pointer; min-width:92px; text-align:center;}
    .tab-btn.active{background:#1b3554; border-color:#2a466b; color:#e6edf3;}
    .tab-panel{display:none;}
    .tab-panel.active{display:block;}
    .card-section{border:1px solid #223247; border-radius:12px; padding:14px; background:#0f1824; margin-top:10px;}
    .stack{display:grid; gap:12px;}
    .panel-note{margin:4px 0 0; font-size:12px; color:#8ea7c4;}
    .species-list{display:grid; gap:8px;}
    .species-row{display:grid; grid-template-columns: auto 1fr 150px; align-items:center; gap:10px; padding:10px; border:1px solid #223247; border-radius:10px; background:#0f1824;}
    .species-head{display:flex; align-items:center; gap:8px; font-weight:700; color:#e6edf3;}
    .species-pill{display:inline-flex; align-items:center; gap:6px; padding:4px 8px; border-radius:999px; border:1px solid #2a3a52; background:#132235; font-size:12px;}
    .species-shape{width:18px; height:18px; display:inline-block; border:2px solid #e6edf3; border-radius:50%;}
    .species-shape.triangle{width:0; height:0; border-left:10px solid transparent; border-right:10px solid transparent; border-top:18px solid #e6edf3; border-radius:0; border:0;}
    .species-controls{display:flex; gap:10px; align-items:center; justify-content:flex-end;}
    .modal-backdrop{
      position:fixed; inset:0; background:rgba(8,12,18,0.72); display:none; align-items:center; justify-content:center; z-index:20;
    }
    .modal{
      background:#0f1620; border:1px solid #2a3a52; border-radius:14px; padding:16px; width:360px; box-shadow:0 20px 60px rgba(0,0,0,0.55);
    }
    .modal h3{margin:0 0 10px; color:#dce6f3;}
    .modal .kv{grid-template-columns: 120px 1fr;}
    .modal .actions{display:flex; gap:8px; margin-top:14px; flex-wrap:wrap;}
    .controls-top{display:flex; justify-content:space-between; gap:12px; align-items:center; flex-wrap:wrap;}
    .settings-toggle{display:flex; align-items:center; gap:10px; justify-content:flex-end;}
    .ghost{background:transparent; border-color:#2a3a52; color:#c9d6e2;}
    .drawer-backdrop{position:fixed; inset:0; background:rgba(6,10,16,0.6); backdrop-filter: blur(2px); opacity:0; pointer-events:none; transition:opacity .2s ease; z-index:30;}
    .drawer{position:fixed; top:0; right:0; width:min(480px, 92vw); height:100vh; background:#0f1620; border-left:1px solid #1f2a37; box-shadow:-16px 0 40px rgba(0,0,0,0.45); transform:translateX(100%); transition:transform .25s ease; z-index:31; display:flex; flex-direction:column;}
    .drawer.open{transform:translateX(0);}
    .drawer-backdrop.open{opacity:1; pointer-events:auto;}
    .drawer-header{padding:16px; border-bottom:1px solid #1f2a37; display:flex; justify-content:space-between; align-items:center;}
    .drawer-title{font-size:18px; font-weight:800;}
    .drawer-body{padding:16px; overflow-y:auto; height:100%;}
    .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #2a3a52; background:#132235; font-size:12px; color:#9fb0c3;}
    .stage{max-width:1600px; margin:0 auto; padding:18px; display:grid; gap:14px;}
    .map-area{display:grid; gap:10px;}
    .map-head{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .overlay-switch{display:flex; gap:6px; align-items:center; flex-wrap:wrap;}
    .overlay-switch .label{font-size:13px; color:#9fb0c3;}
    .overlay-btn{padding:8px 10px; border-radius:12px; border:1px solid #1f2a37; background:#0f1a2a; color:#c9d6e2; cursor:pointer; font-size:13px;}
    .overlay-btn.active{background:#1b3554; border-color:#2a466b; color:#e6edf3; box-shadow:0 0 0 1px rgba(90,162,247,0.4);}
    .legend-card{position:absolute; inset:auto 12px 12px auto; z-index:7; background:rgba(10,16,24,0.82); border:1px solid #223247; border-radius:12px; padding:10px 12px; display:grid; gap:6px; min-width:210px; box-shadow:0 10px 28px rgba(0,0,0,0.5); font-size:13px;}
    .legend-title{font-weight:700; color:#dce6f3;}
    .legend-row{display:flex; align-items:center; gap:8px; color:#c9d6e2;}
    .legend-swatch{width:16px; height:16px; border-radius:4px; border:1px solid #d9e2f3;}
    .legend-swatch.circle{border-radius:50%;}
    .legend-swatch.tri{width:0; height:0; border-left:9px solid transparent; border-right:9px solid transparent; border-top:16px solid #d9e2f3; border-radius:0; border:0;}
    .floating-toolbar{position:absolute; inset:auto 16px 16px auto; display:flex; flex-direction:column; gap:8px; z-index:20; align-items:flex-end; pointer-events:none;}
    .toolbar-row{display:flex; gap:6px; flex-wrap:wrap; justify-content:flex-end;}
    .toolbar-card{background:rgba(12,18,26,0.92); border:1px solid #1f2a37; border-radius:14px; padding:10px; box-shadow:0 12px 34px rgba(0,0,0,0.45); pointer-events:auto; min-width:240px;}
    .floating-settings{position:fixed; right:18px; bottom:20px; z-index:25;}
    .floating-controls-title{font-size:12px; color:#8ea7c4; margin-bottom:6px;}
    .fab{border-radius:999px; padding:12px 18px; font-weight:700; box-shadow:0 12px 32px rgba(0,0,0,0.45);}
    .hud-grid{grid-template-columns: repeat(auto-fit, minmax(120px,1fr));}
    .hud-item .value{font-size:20px;}
    .hud-item{padding:8px 10px;}
    .hud-meta{font-size:12px;}
    .hud-pill{padding:6px 10px;}
    .hud-header{display:flex; justify-content:space-between; gap:8px; align-items:center;}
    .hud-actions{display:flex; gap:6px;}
    .badge{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#12263a; border:1px solid #20354e; color:#9fb0c3; font-size:12px;}
    .compact-note{font-size:13px; color:#8ea7c4;}
    .map-status{display:flex; gap:8px; align-items:center; flex-wrap:wrap;}
    .map-hint{font-size:13px; color:#8ea7c4;}
    .pill-note{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #223247; background:rgba(14,22,32,0.86); font-size:12px; color:#9fb0c3;}
    .quick-controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .quick-controls button{padding:8px 10px;}
    .quick-controls .mini{padding:6px 8px; font-size:13px;}
    .tiny{font-size:12px; color:#8ea7c4;}
    .drawer-body .grid3{display:grid; grid-template-columns: repeat(auto-fit, minmax(180px,1fr)); gap:12px;}
    @media (max-width: 1100px){
      .floating-toolbar{position:static; padding:8px 0; align-items:flex-start;}
      .floating-settings{position:fixed; right:14px; bottom:14px;}
      .canvas-hud{position:relative; inset:auto; margin-top:10px;}
      .canvas-wrap{padding:10px; min-height:60vh;}
      #p5-container{min-height:520px;}
    }
  </style>
</head>

<body>
  <header>
    <div class="title">Bio-Sphere Manager デモ</div>
    <div class="sub">p5.js + Chart.js / GitHub Pages 向け 単一HTML（決定論シード・CSVログ付き）</div>
  </header>

  <div class="stage">
    <div class="map-area">
      <div class="map-head">
        <div class="map-status">
          <span class="badge">マップ優先ビュー</span>
          <span class="compact-note">HUDはドラッグで動かせます。設定ドロワーは右下「設定」から。</span>
          <span class="pill-note">「全滅まで」モードは長時間になる場合があります</span>
        </div>
        <div class="overlay-switch" role="group" aria-label="表示モード">
          <span class="label">表示モード</span>
          <button class="overlay-btn active" data-mode="life">生物</button>
          <button class="overlay-btn" data-mode="terrain">地形</button>
          <button class="overlay-btn" data-mode="plant">植物量</button>
          <button class="overlay-btn" data-mode="temp">気温</button>
          <button class="overlay-btn" data-mode="rain">雨量/水分</button>
        </div>
      </div>
      <div class="canvas-wrap">
        <div id="p5-container"></div>
        <div class="canvas-hud" aria-live="polite" id="hud">
          <div class="hud-header">
            <div class="hud-status">
              <div class="label">状態</div>
              <div class="hud-pill" id="outStatus">停止中</div>
            </div>
            <div class="hud-actions">
              <button class="ghost" id="btnHudToggle">⤢</button>
            </div>
          </div>
          <div class="hud-top">
            <div class="hud-meta">ステップ <span id="outStep">0</span></div>
            <div class="hud-meta mono">seed: <span id="outSeed">daily</span></div>
          </div>
          <div class="hud-grid">
            <div class="hud-item">
              <div class="label">草</div>
              <div class="value" id="outGrass">0</div>
            </div>
            <div class="hud-item">
              <div class="label">草食</div>
              <div class="value" id="outHerb">0</div>
            </div>
            <div class="hud-item">
              <div class="label">肉食</div>
              <div class="value" id="outCarn">0</div>
            </div>
            <div class="hud-item">
              <div class="label">季節</div>
              <div class="value" id="outSeason">－</div>
            </div>
            <div class="hud-item">
              <div class="label">気温</div>
              <div class="value" id="outTemp">－</div>
            </div>
            <div class="hud-item">
              <div class="label">雨量</div>
              <div class="value" id="outRain">－</div>
            </div>
            <div class="hud-item">
              <div class="label">スコア</div>
              <div class="value" id="outScore">0</div>
              <div class="tiny" id="outScoreDetail">生存・多様性・安定度</div>
            </div>
          </div>
        </div>
        <div class="legend-card" id="legendCard">
          <div class="legend-title">凡例</div>
          <div class="legend-row"><span class="legend-swatch" style="background:linear-gradient(90deg,#244d31,#4f9f6d);"></span><span>草（バイオマス濃淡）</span></div>
          <div class="legend-row"><span class="legend-swatch circle" style="background:rgb(70,180,255);"></span><span>草食</span></div>
          <div class="legend-row"><span class="legend-swatch tri" style="border-top-color:rgb(240,160,80);"></span><span>肉食</span></div>
          <div class="legend-row tiny">地形・天候は「表示モード」で切替</div>
        </div>
        <div class="floating-toolbar">
          <div class="toolbar-card">
            <div class="floating-controls-title">クイック操作</div>
            <div class="toolbar-row">
              <button id="btnStart" class="primary">開始/停止</button>
              <button id="btnStep">1ステップ</button>
              <button id="btnReset" class="danger">リセット</button>
              <button id="btnForceEnd" class="ghost">強制終了</button>
            </div>
            <div class="toolbar-row" style="margin-top:4px;">
              <button id="btnCSV">CSV</button>
              <label class="tiny">デフォルトシナリオ</label>
              <select id="selScenario">
                <option value="">選択</option>
                <option value="temperate">温帯草原（シカ-オオカミ）</option>
                <option value="river">河川敷（ウサギ-キツネ）</option>
                <option value="arid">乾燥地</option>
                <option value="grassland">旧：草原（安定）</option>
                <option value="dryCollapse">旧：乾燥（崩壊）</option>
              </select>
              <button id="btnApplyScenario" class="primary">適用してリセット</button>
            </div>
            <div class="toolbar-row" style="margin-top:4px;">
              <button id="btnOpenDrawerInline" class="primary">⚙ 設定を開く</button>
            </div>
          </div>
        </div>
      </div>
      <div class="note">同じseed・同じ初期パラメータなら挙動が再現されます（Math.randomは未使用）。</div>
    </div>
  </div>

  <div class="floating-settings">
    <button id="btnOpenDrawer" class="fab primary">⚙ 設定</button>
  </div>

  <div class="drawer-backdrop" id="drawerBackdrop"></div>
  <aside class="drawer" id="settingsDrawer" aria-hidden="true">
    <div class="drawer-header">
      <div class="drawer-title">設定</div>
      <div class="chip">高度なパラメータ</div>
      <button id="btnCloseDrawer" class="ghost">閉じる</button>
    </div>
    <div class="drawer-body">
      <div class="tabs" role="tablist">
        <button class="tab-btn active" data-tab="tab-control">操作</button>
        <button class="tab-btn" data-tab="tab-pop">個体群</button>
        <button class="tab-btn" data-tab="tab-map">マップ</button>
        <button class="tab-btn" data-tab="tab-detail">詳細</button>
      </div>

      <div id="tab-control" class="tab-panel active">
        <details class="section" open>
          <summary>高度</summary>
          <div class="section-body stack">
            <div class="row">
              <div>
                <label class="note">seed文字列（空欄なら日替わりを使用）</label><br>
                <input id="inSeed" type="text" placeholder="例: exp-001" />
              </div>
              <label class="note"><input id="chkDaily" type="checkbox" checked /> 日替わりseed</label>
            </div>
            <div class="ctrl">
              <label>描画速度（FPS）<div class="help">高くすると描画が滑らかになります</div></label>
              <div class="row">
                <input id="slFPS" type="range" min="10" max="60" value="30" />
                <span class="mono" id="valFPS">30</span>
              </div>
            </div>
            <div class="ctrl">
              <label>ログ間隔（ステップ）<div class="help">CSV/グラフの更新頻度</div></label>
              <input id="inLogEvery" type="number" min="1" max="50" value="5" />
            </div>
          </div>
        </details>
      </div>

      <div id="tab-pop" class="tab-panel">
        <details class="section" open>
          <summary>基本</summary>
          <div class="section-body stack">
            <div class="ctrl">
              <label>草の成長率（0〜0.20）<div class="help">増やすほど草が生えやすくなります</div></label>
              <div class="row">
                <input id="slGrass" type="range" min="0" max="0.20" step="0.005" value="0.02" />
                <span class="mono" id="valGrass">0.02</span>
              </div>
            </div>
            <div class="grid2">
              <div class="ctrl">
                <label>初期 草 数<div class="help">開始時の草セル数</div></label>
                <input id="inInitGrass" type="number" min="0" max="2500" value="800" />
              </div>
            </div>
            <div class="card-section">
              <div class="note">種ごとの有効化と初期個体数を設定できます（草食2種・肉食2種）。</div>
              <div id="speciesList" class="species-list"></div>
            </div>
          </div>
        </details>
        <details class="section" open>
          <summary>高度</summary>
          <div class="section-body stack">
            <div class="grid2">
              <div class="ctrl">
                <label>草食：採食エネルギー<div class="help">草1セルを食べたときの獲得量</div></label>
                <input id="inHerbGain" type="number" min="1" max="50" value="12" />
              </div>
              <div class="ctrl">
                <label>草食：繁殖閾値<div class="help">エネルギーが閾値以上なら繁殖試行</div></label>
                <input id="inHerbRepro" type="number" min="5" max="100" value="28" />
              </div>
              <div class="ctrl">
                <label>肉食：捕食エネルギー<div class="help">草食を食べたときの獲得量</div></label>
                <input id="inCarnGain" type="number" min="1" max="80" value="22" />
              </div>
              <div class="ctrl">
                <label>肉食：繁殖閾値<div class="help">エネルギーが閾値以上なら繁殖試行</div></label>
                <input id="inCarnRepro" type="number" min="5" max="120" value="45" />
              </div>
            </div>
            <div class="card-section">
              <div class="row" style="margin-bottom:8px;">
                <label class="note"><input id="chkCompetition" type="checkbox" /> 競合（密度依存）を有効化</label>
              </div>
              <div class="grid2">
                <div class="ctrl">
                  <label>草食の環境収容力K<div class="help">草食が増えるほど繁殖成功率が低下</div></label>
                  <input id="inHerbK" type="number" min="1" max="5000" value="400" />
                </div>
                <div class="ctrl">
                  <label>肉食の環境収容力K<div class="help">肉食が増えるほど繁殖成功率が低下</div></label>
                  <input id="inCarnK" type="number" min="1" max="5000" value="200" />
                </div>
              </div>
              <div class="ctrl">
                <label>密度コスト係数（代謝追加）<div class="help">個体が密集すると代謝コストが増加</div></label>
                <input id="inDensityCost" type="number" min="0" max="50" value="0" />
              </div>
            </div>
            <div class="grid2">
              <div class="ctrl">
                <label>草食の寿命[step]<div class="help">寿命を超えると老衰で死亡</div></label>
                <input id="inHerbMaxAge" type="number" min="10" max="2000" value="120" />
              </div>
              <div class="ctrl">
                <label>肉食の寿命[step]<div class="help">寿命を超えると老衰で死亡</div></label>
                <input id="inCarnMaxAge" type="number" min="10" max="2000" value="160" />
              </div>
            </div>
          </div>
        </details>
      </div>

      <div id="tab-map" class="tab-panel">
        <details class="section" open>
          <summary>表示と終了条件</summary>
          <div class="section-body stack">
            <div class="ctrl">
              <label>終了条件<div class="help">指定の種が絶滅したら停止 / 全滅まで走らせる</div></label>
              <select id="selEndCondition">
                <option value="anyExtinct">どれか1種が絶滅したら終了</option>
                <option value="animalExtinct">草食か肉食が絶滅したら終了</option>
                <option value="totalExtinct">全生物が絶滅するまで</option>
              </select>
            </div>
            <div class="note">「全滅まで」は植物も含めすべて0になるまで継続します。長く続く場合はクイック操作の「強制終了」を利用してください。</div>
            <div class="ctrl">
              <label>最大ステップ<div class="help">上限に達すると終了</div></label>
              <input id="inMaxSteps" type="number" min="10" max="20000" value="2000" />
            </div>
            <div class="ctrl">
              <label>拡大率<div class="help">1.0〜2.0の間でマップ描画を拡大縮小します</div></label>
              <div class="row">
                <input id="slZoom" type="range" min="1.0" max="2.0" step="0.05" value="1.25" />
                <span class="mono" id="valZoom">1.25</span>
              </div>
            </div>
            <div class="ctrl">
              <label>演出<div class="help">捕食リング・死亡マーカーなど視認性のための効果（挙動は不変）</div></label>
              <label class="note"><input id="chkEffects" type="checkbox" checked /> 演出ON</label>
            </div>
          </div>
        </details>
        <details class="section" open>
          <summary>環境プリセット</summary>
          <div class="section-body stack">
            <div class="ctrl">
              <label>環境モード<div class="help">地形比率と年間の気温・雨量カーブ、植物成長係数をまとめて設定</div></label>
              <div class="row">
                <select id="selEnvPreset">
                  <option value="temperateEnv">温帯草原（標準）</option>
                  <option value="riverEnv">河川敷（川多め）</option>
                  <option value="aridEnv">乾燥地（雨量少）</option>
                  <option value="monsoonEnv">雨季・乾季（季節変動強）</option>
                </select>
                <button id="btnApplyEnvironment" class="primary">環境を適用してリセット</button>
              </div>
            </div>
            <div class="note">シナリオとは独立して環境のみを切り替えます。</div>
          </div>
        </details>
        <details class="section" open>
          <summary>環境パラメータ</summary>
          <div class="section-body stack">
            <div class="grid3">
              <div class="ctrl">
                <label>川割合<div class="help">0〜0.40くらいを推奨</div></label>
                <input id="inRiverRatio" type="number" min="0" max="0.6" step="0.01" value="0.12" />
              </div>
              <div class="ctrl">
                <label>岩割合<div class="help">0〜0.30くらいを推奨</div></label>
                <input id="inRockRatio" type="number" min="0" max="0.5" step="0.01" value="0.10" />
              </div>
              <div class="ctrl">
                <label>森林割合<div class="help">残りから自動配分されます</div></label>
                <input id="inForestRatio" type="number" min="0" max="0.6" step="0.01" value="0.18" />
              </div>
            </div>
            <div class="grid3">
              <div class="ctrl">
                <label>平均気温（℃）</label>
                <input id="inAvgTemp" type="number" min="-10" max="40" step="0.5" value="18" />
              </div>
              <div class="ctrl">
                <label>年較差（季節振幅）</label>
                <input id="inTempAmp" type="number" min="0" max="20" step="0.5" value="12" />
              </div>
              <div class="ctrl">
                <label>平均雨量</label>
                <input id="inAvgRain" type="number" min="0" max="200" step="1" value="80" />
              </div>
            </div>
            <div class="grid3">
              <div class="ctrl">
                <label>雨季振幅</label>
                <input id="inRainAmp" type="number" min="0" max="120" step="1" value="45" />
              </div>
              <div class="ctrl">
                <label>植物成長係数</label>
                <input id="inPlantScale" type="number" min="0.2" max="2" step="0.05" value="1" />
              </div>
              <div class="ctrl">
                <label>メモ<div class="help">調整後に「環境を適用してリセット」を押すと反映されます</div></label>
                <div class="badge">地形・季節パラメータ</div>
              </div>
            </div>
          </div>
        </details>
      </div>

      <div id="tab-detail" class="tab-panel">
        <details class="section" open>
          <summary>基本</summary>
          <div class="section-body stack">
            <div class="kv">
              <div class="label">終了理由</div><div class="value mono" id="outEndReason">-</div>
            </div>
            <div class="kv">
              <div class="label">総ステップ</div><div class="value mono" id="outTotalStep">0</div>
            </div>
            <div class="kv">
              <div class="label">最終個体数</div><div class="value mono" id="outFinalCounts">草0 / 草食0 / 肉食0</div>
            </div>
            <div class="kv">
              <div class="label">最大個体数</div><div class="value mono" id="outPeakCounts">草0 / 草食0 / 肉食0</div>
            </div>
            <div class="kv">
              <div class="label">死亡内訳</div><div class="value mono" id="outDeaths">草食:飢餓0 捕食0 老衰0 / 肉食:飢餓0 老衰0</div>
            </div>
            <div class="row" style="margin-top:10px;">
              <button id="btnCopyResult">結果をコピー</button>
              <button id="btnCopyScore" class="primary">スコアをコピー</button>
            </div>
            <div class="note">CSV列: schema_version, seed, step, grass_count, herbivore_count, carnivore_count, death_herbivore_starve, death_herbivore_eaten, death_carnivore_starve, death_herbivore_age, death_carnivore_age, herb_K, carn_K, competition_enabled, herb_repro_success_rate, carn_repro_success_rate, biomass_total, temperature, rainfall, season_name, 以降に各species_count列</div>
          </div>
        </details>
        <details class="section" open>
          <summary>高度</summary>
          <div class="section-body">
            <div class="card" style="border-color:#223247;">
              <h2 style="padding:12px 12px 0">個体数グラフ</h2>
              <div class="pad">
                <canvas id="chart" height="220"></canvas>
              </div>
            </div>
          </div>
        </details>
      </div>
    </div>
  </aside>
  <div class="modal-backdrop" id="endModal">
    <div class="modal">
      <h3>シミュレーション終了</h3>
      <div class="kv">
        <div class="label">終了理由</div><div class="value mono" id="modalReason">-</div>
      </div>
      <div class="kv">
        <div class="label">総ステップ</div><div class="value mono" id="modalSteps">0</div>
      </div>
      <div class="kv">
        <div class="label">最終個体数</div><div class="value mono" id="modalCounts">草0 / 草食0 / 肉食0</div>
      </div>
      <div class="kv">
        <div class="label">死亡内訳</div><div class="value mono" id="modalDeaths">-</div>
      </div>
      <div class="kv">
        <div class="label">スコア</div><div class="value mono" id="modalScore">0</div>
      </div>
      <div class="kv">
        <div class="label">スコア内訳</div><div class="value mono" id="modalScoreDetail">-</div>
      </div>
      <div class="actions">
        <button id="btnModalReset" class="primary">リセット</button>
        <button id="btnModalCSV">CSVダウンロード</button>
        <button id="btnModalCopy">結果をコピー</button>
        <button id="btnModalCopyScore">スコアをコピー</button>
      </div>
    </div>
  </div>

<script>
/**
 * Bio-Sphere Manager Demo
 * - 単一HTML（GitHub Pages向け）
 * - p5.jsで描画、Chart.jsで個体数推移
 * - 決定論のため seed RNG（Math.randomは使わない）
 * - CSVログ出力（研究・検証用の最低限）
 */

/* ========= 決定論RNG（Mulberry32） ========= */
function hash32FromString(str){
  // 文字列を32bitに潰す（簡易ハッシュ）
  let h = 2166136261 >>> 0;
  for(let i=0;i<str.length;i++){
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}
function mulberry32(seed){
  let a = seed >>> 0;
  return function(){
    a |= 0; a = (a + 0x6D2B79F5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

/* ========= シミュレーション設定 ========= */
const GRID = 50;
const BASE_CANVAS = 900;
let mapScale = 1.25;
let canvasSize = Math.round(BASE_CANVAS * mapScale);
let cellSize = canvasSize / GRID;
const N = GRID * GRID;
const SCHEMA_VERSION = 4;
const SCORE_BIO_BONUS = 150;
const SCORE_STABILITY_BASE = 220;
const MAX_STABILITY_SAMPLES = 160;
const EFFECT_LIFETIME = 22;
const DEATH_MARK_LIFETIME = 26;

const TERRAIN = {
  GRASSLAND: 0,
  ROCK: 1,
  RIVER: 2,
  FOREST: 3,
};
const TERRAIN_KEYS = Object.keys(TERRAIN);

const SPECIES_DEFS = [
  {
    id: 'herb_a',
    nameJP: 'ハミング草食',
    color: [70, 180, 255],
    shape: 'circle',
    diet: 'herbivore',
    metabolism: 1,
    maxAge: 130,
    gains: {grassDelta: 0},
    reproDelta: 0,
    defaultEnabled: true,
    defaultInit: 50,
  },
  {
    id: 'herb_b',
    nameJP: 'モグモグ草食',
    color: [90, 220, 200],
    shape: 'circle',
    diet: 'herbivore',
    metabolism: 1,
    maxAge: 150,
    gains: {grassDelta: -2},
    reproDelta: -4,
    defaultEnabled: true,
    defaultInit: 40,
  },
  {
    id: 'carn_a',
    nameJP: 'シャドウ肉食',
    color: [240, 90, 170],
    shape: 'triangle',
    diet: 'carnivore',
    metabolism: 1,
    maxAge: 180,
    gains: {herbivoreDelta: 0},
    reproDelta: 0,
    defaultEnabled: true,
    defaultInit: 16,
  },
  {
    id: 'carn_b',
    nameJP: 'ブレード肉食',
    color: [255, 140, 90],
    shape: 'triangle',
    diet: 'carnivore',
    metabolism: 2,
    maxAge: 150,
    gains: {herbivoreDelta: -4},
    reproDelta: -6,
    defaultEnabled: true,
    defaultInit: 10,
  },
];
const SPECIES_MAP = Object.fromEntries(SPECIES_DEFS.map(s=>[s.id, s]));

let rng = mulberry32(1);
let running = false;
let step = 0;
let tickPerFrame = 1;
let statusMessage = '停止中';
let currentSeed = 'daily:0000-00-00';

// 草バイオマス（0..plantK）
let biomass = new Float32Array(N);
let grassTone = new Uint8Array(N); // 草の濃淡（決定論）
let terrain = new Uint8Array(N);
let terrainPattern = new Uint32Array(N);

// 動物
let animals = {};

// 作業用：セルごとの草食インデックス（再利用してGCを抑える）
let herbivoreAt = Array.from({length:N}, ()=>[]);

let speciesSettings = {};
let activeHerbSpecies = [];
let activeCarnSpecies = [];

// ログ（CSV出力用）
let logs = [];
let logEvery = 5;
let herbReproAttempts = 0;
let herbReproSuccess = 0;
let carnReproAttempts = 0;
let carnReproSuccess = 0;
let overlayMode = 'life';
let hudCollapsed = false;
let hudOffset = {x:12,y:12};
let p5Instance = null;
let effectsEnabled = true;
let visualEffects = [];
let stabilitySeries = [];
let scoreState = {total:0, base:0, bioBonus:0, biodiversity:0, stability:0};

// プリセット（シナリオ）
const PRESETS = {
  temperate: {
    label: '温帯草原（シカ-オオカミ）',
    values: {
      initGrass: 1400,
      species: {herb_a: 62, herb_b: 34, carn_a: 12, carn_b: 6},
      grassGrowthRate: 0.02, plantK: 10, herbGain: 12, carnGain: 22,
      herbRepro: 30, carnRepro: 46, herbMaxAge: 140, carnMaxAge: 170,
      climateIntensity: 1.05, terrainMix: 0.32,
      endCondition: 'animalExtinct', maxSteps: 3000, logEvery: 5
    }
  },
  river: {
    label: '河川敷（ウサギ-キツネ）',
    values: {
      initGrass: 1320,
      species: {herb_a: 70, herb_b: 28, carn_a: 10, carn_b: 5},
      grassGrowthRate: 0.021, plantK: 11, herbGain: 13, carnGain: 21,
      herbRepro: 29, carnRepro: 44, herbMaxAge: 135, carnMaxAge: 165,
      climateIntensity: 1.0, terrainMix: 0.52,
      endCondition: 'animalExtinct', maxSteps: 2800, logEvery: 5
    }
  },
  arid: {
    label: '乾燥地',
    values: {
      initGrass: 720,
      species: {herb_a: 40, herb_b: 20, carn_a: 9, carn_b: 6},
      grassGrowthRate: 0.011, plantK: 7, herbGain: 11, carnGain: 20,
      herbRepro: 31, carnRepro: 48, herbMaxAge: 120, carnMaxAge: 160,
      climateIntensity: 0.82, terrainMix: 0.46,
      endCondition: 'anyExtinct', maxSteps: 2200, logEvery: 4
    }
  },
  grassland: {
    label: '旧：草原（安定）',
    values: {
      initGrass: 1250,
      species: {herb_a: 55, herb_b: 35, carn_a: 11, carn_b: 7},
      grassGrowthRate: 0.018, plantK: 8, herbGain: 12, carnGain: 22,
      herbRepro: 28, carnRepro: 45, herbMaxAge: 130, carnMaxAge: 170,
      climateIntensity: 1.0, terrainMix: 0.30,
      endCondition: 'animalExtinct', maxSteps: 2600, logEvery: 5
    }
  },
  dryCollapse: {
    label: '旧：乾燥（崩壊）',
    values: {
      initGrass: 620,
      species: {herb_a: 38, herb_b: 22, carn_a: 9, carn_b: 7},
      grassGrowthRate: 0.009, plantK: 7, herbGain: 11, carnGain: 20,
      herbRepro: 30, carnRepro: 48, herbMaxAge: 120, carnMaxAge: 165,
      climateIntensity: 0.9, terrainMix: 0.28,
      endCondition: 'anyExtinct', maxSteps: 1800, logEvery: 4
    }
  }
};

const ENV_PRESETS = {
  temperateEnv: {
    label: '温帯草原（標準）',
    env: {river:0.12, rock:0.1, forest:0.18, avgTemp:18, tempAmp:12, avgRain:80, rainAmp:45, plantScale:1}
  },
  riverEnv: {
    label: '河川敷（川多め）',
    env: {river:0.20, rock:0.08, forest:0.20, avgTemp:17, tempAmp:11, avgRain:92, rainAmp:50, plantScale:1.05}
  },
  aridEnv: {
    label: '乾燥地（雨量少）',
    env: {river:0.08, rock:0.16, forest:0.14, avgTemp:22, tempAmp:10, avgRain:42, rainAmp:24, plantScale:0.85}
  },
  monsoonEnv: {
    label: '雨季・乾季（季節変動強）',
    env: {river:0.16, rock:0.1, forest:0.22, avgTemp:20, tempAmp:14, avgRain:86, rainAmp:70, plantScale:1.1}
  }
};

// パラメータ（UIから読み込み）
let P = {
  initGrass: 800,
  grassGrowthRate: 0.02,
  plantK: 8,
  herbGain: 12,
  herbRepro: 28,
  carnGain: 22,
  carnRepro: 45,
  metabolism: 1,
  herbMaxAge: 120,
  carnMaxAge: 160,
  avgTemp: 18,
  tempAmp: 12,
  avgRain: 80,
  rainAmp: 45,
  riverRatio: 0.12,
  rockRatio: 0.10,
  forestRatio: 0.18,
  plantGrowthScale: 1,
  endCondition: 'anyExtinct',
  maxSteps: 2000,
  competition: false,
  herbK: 400,
  carnK: 200,
  densityCostScale: 0,
};

// 死因ログ（最低限）
let deathHerbStarve = 0;
let deathCarnStarve = 0;
let deathHerbEaten = 0;
let deathHerbAge = 0;
let deathCarnAge = 0;

// 気候・季節
let weatherState = {season:'－', temperature:0, rainfall:0};

// 結果表示用
let endReason = '';
let peakCounts = {grass:0, herb:0, carn:0};

/* ========= UI ========= */
const el = (id)=>document.getElementById(id);

function todayKey(){
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const day = String(d.getDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}

function getSeedString(){
  if(el('chkDaily').checked) return `daily:${todayKey()}`;
  const s = el('inSeed').value.trim();
  return s ? s : `manual:${todayKey()}`;
}

function readParamsFromUI(){
  P.initGrass = clampInt(parseInt(el('inInitGrass').value,10), 0, N);
  P.grassGrowthRate = clampFloat(parseFloat(el('slGrass').value), 0, 0.2);
  P.herbGain  = clampInt(parseInt(el('inHerbGain').value,10), 1, 200);
  P.herbRepro = clampInt(parseInt(el('inHerbRepro').value,10), 2, 500);
  P.carnGain  = clampInt(parseInt(el('inCarnGain').value,10), 1, 300);
  P.carnRepro = clampInt(parseInt(el('inCarnRepro').value,10), 2, 800);
  P.herbMaxAge = clampInt(parseInt(el('inHerbMaxAge').value,10), 10, 2000);
  P.carnMaxAge = clampInt(parseInt(el('inCarnMaxAge').value,10), 10, 2000);
  P.avgTemp = clampFloat(parseFloat(el('inAvgTemp').value), -10, 40);
  P.tempAmp = clampFloat(parseFloat(el('inTempAmp').value), 0, 20);
  P.avgRain = clampFloat(parseFloat(el('inAvgRain').value), 0, 200);
  P.rainAmp = clampFloat(parseFloat(el('inRainAmp').value), 0, 120);
  P.riverRatio = clampFloat(parseFloat(el('inRiverRatio').value), 0, 0.6);
  P.rockRatio = clampFloat(parseFloat(el('inRockRatio').value), 0, 0.5);
  P.forestRatio = clampFloat(parseFloat(el('inForestRatio').value), 0, 0.6);
  P.plantGrowthScale = clampFloat(parseFloat(el('inPlantScale').value), 0.2, 2);
  const endVal = el('selEndCondition').value;
  P.endCondition = endVal === 'animalExtinct' ? 'animalExtinct' : (endVal === 'totalExtinct' ? 'totalExtinct' : 'anyExtinct');
  P.maxSteps = clampInt(parseInt(el('inMaxSteps').value,10), 10, 20000);
  P.competition = el('chkCompetition').checked;
  P.herbK = clampInt(parseInt(el('inHerbK').value,10), 1, 10000);
  P.carnK = clampInt(parseInt(el('inCarnK').value,10), 1, 10000);
  P.densityCostScale = clampInt(parseInt(el('inDensityCost').value,10), 0, 1000);
  effectsEnabled = el('chkEffects').checked;
  logEvery = clampInt(parseInt(el('inLogEvery').value,10), 1, 50);

  const fps = clampInt(parseInt(el('slFPS').value,10), 10, 60);
  el('valFPS').textContent = fps;
  tickPerFrame = Math.max(1, Math.round(fps / 30)); // ざっくり（後で精密化可）

  el('valGrass').textContent = P.grassGrowthRate.toFixed(3);
  el('valZoom').textContent = mapScale.toFixed(2);
  el('valFPS').textContent = String(fps);
  updateZoomFromUI();
  updateSpeciesSettingsFromUI();
  updateActiveSpeciesLists();
  refreshSpeciesTraitLabels();
}
function clampInt(v,min,max){ if(Number.isNaN(v)) v=min; return Math.min(max, Math.max(min, v)); }
function clampFloat(v,min,max){ if(Number.isNaN(v)) v=min; return Math.min(max, Math.max(min, v)); }
function updateZoomFromUI(){
  const z = clampFloat(parseFloat(el('slZoom').value), 1, 2);
  mapScale = z;
  canvasSize = Math.round(BASE_CANVAS * mapScale);
  cellSize = canvasSize / GRID;
  el('valZoom').textContent = mapScale.toFixed(2);
  if(p5Instance){
    p5Instance.resizeCanvas(canvasSize, canvasSize);
  }
}
function placeHud(){
  const hud = el('hud');
  if(!hud) return;
  hud.style.left = `${hudOffset.x}px`;
  hud.style.top = `${hudOffset.y}px`;
}
function getEnergySize(energy, baseSize, threshold){
  const ratio = clampFloat(energy / Math.max(1, threshold), 0, 1.2);
  return baseSize * (0.75 + ratio * 0.35);
}
function drawTriangle(p, cx, cy, size){
  const h = (Math.sqrt(3) / 2) * size;
  p.triangle(cx, cy - h / 2, cx - size / 2, cy + h / 2, cx + size / 2, cy + h / 2);
}
function drawLegend(p){
  const x = 12; const y = 12; const w = 240; const h = 60 + SPECIES_DEFS.length * 22;
  p.noStroke();
  p.fill(10, 16, 24, 230);
  p.rect(x, y, w, h, 12);
  p.textAlign(p.LEFT, p.CENTER);
  p.textSize(13);
  p.fill(210);
  p.text('凡例', x + 12, y + 18);

  // 草
  p.fill(60, 150, 92);
  p.rect(x + 12, y + 32, 24, 16, 3);
  p.fill(215);
  p.text('草（濃淡で草量）', x + 44, y + 40);

  let offsetY = 60;
  for(const sp of SPECIES_DEFS){
    const c = `rgb(${sp.color.join(',')})`;
    p.stroke(245);
    p.strokeWeight(2.1);
    p.fill(...sp.color);
    if(sp.shape === 'triangle'){
      drawTriangle(p, x + 24, y + offsetY, 18);
    } else {
      p.circle(x + 24, y + offsetY, 16);
    }
    drawEffects(p);
    p.noStroke();
    p.fill(215);
    p.text(`${sp.nameJP}（${sp.diet==='herbivore'?'草食':'肉食'}）`, x + 44, y + offsetY);
    offsetY += 20;
  }
}
function speciesColor(sp){
  return `rgb(${sp.color.join(',')})`;
}
function drawTerrainPattern(p, x, y, t, pat){
  const baseX = x * cellSize;
  const baseY = y * cellSize;
  const seed = pat >>> 0;
  if(t === TERRAIN.RIVER){
    p.stroke(140, 200, 255, 120);
    p.strokeWeight(Math.max(1, cellSize * 0.08));
    const offset = (seed % 12) * 0.06;
    p.line(baseX, baseY + offset, baseX + cellSize, baseY + cellSize * 0.28 + offset * 0.02);
    p.line(baseX, baseY + cellSize * 0.62 + offset * 0.03, baseX + cellSize, baseY + cellSize * 0.96);
  } else if(t === TERRAIN.ROCK){
    p.noStroke();
    p.fill(200, 205, 214, 90);
    const dots = 2 + (seed % 3);
    for(let i=0;i<dots;i++){
      const dx = ((seed >> (i*3)) & 7) / 8;
      const dy = ((seed >> (i*3+2)) & 7) / 8;
      p.rect(baseX + dx * cellSize, baseY + dy * cellSize, cellSize * 0.18, cellSize * 0.18, 3);
    }
  } else if(t === TERRAIN.FOREST){
    p.stroke(46, 120, 82, 120);
    p.strokeWeight(Math.max(1, cellSize * 0.06));
    const stripe = (seed % 4) + 1;
    const start = (seed % 6) / 12;
    for(let i=0;i<stripe;i++){
      const sx = baseX + (start + i * 0.28) * cellSize;
      p.line(sx, baseY, sx, baseY + cellSize);
    }
  } else if(t === TERRAIN.GRASSLAND){
    p.noStroke();
    p.fill(120, 180, 120, 35);
    const diag = (seed % 100) / 100 * cellSize * 0.3;
    p.rect(baseX + diag, baseY + cellSize * 0.65, cellSize * 0.4, cellSize * 0.12, 3);
  }
  p.noStroke();
}
function updateGrassToneMap(seedStr){
  for(let i=0;i<N;i++){
    const h = hash32FromString(`${seedStr}:${i}`);
    grassTone[i] = h % 80; // 0-79の明度
  }
}
function updateTerrainMap(seedStr){
  for(let i=0;i<N;i++){
    const h = hash32FromString(`${seedStr}:terrain:${i}`);
    terrainPattern[i] = hash32FromString(`${seedStr}:terrain:${i}:pat`);
    const roll = (h % 1000) / 1000;
    const river = clampFloat(P.riverRatio, 0, 0.6);
    const rock = clampFloat(P.rockRatio, 0, 0.5);
    const forestBase = clampFloat(P.forestRatio, 0, 0.6);
    const remainder = Math.max(0, 1 - (river + rock + forestBase));
    const forest = clampFloat(forestBase + remainder * 0.25, 0, 0.8);
    if(roll < river){
      terrain[i] = TERRAIN.RIVER;
    } else if(roll < river + rock){
      terrain[i] = TERRAIN.ROCK;
    } else if(roll < river + rock + forest){
      terrain[i] = TERRAIN.FOREST;
    } else {
      terrain[i] = TERRAIN.GRASSLAND;
    }
  }
}
function spawnEffect(type, x, y){
  if(!effectsEnabled) return;
  visualEffects.push({type, x, y, life: type === 'predation' ? EFFECT_LIFETIME : DEATH_MARK_LIFETIME, max: type === 'predation' ? EFFECT_LIFETIME : DEATH_MARK_LIFETIME});
}
function drawEffects(p){
  if(!effectsEnabled){
    visualEffects = [];
    return;
  }
  const next = [];
  for(const eff of visualEffects){
    const progress = eff.life / eff.max;
    const cx = (eff.x + 0.5) * cellSize;
    const cy = (eff.y + 0.5) * cellSize;
    if(eff.type === 'predation'){
      const radius = cellSize * (0.5 + (1 - progress) * 0.8);
      p.noFill();
      p.stroke(255, 180, 120, 120 * progress + 40);
      p.strokeWeight(Math.max(1, 2.5 * progress));
      p.circle(cx, cy, radius);
    } else if(eff.type === 'death'){
      const alpha = 160 * progress;
      p.stroke(230, 110, 130, alpha);
      p.strokeWeight(Math.max(1, cellSize * 0.12));
      const delta = cellSize * 0.32;
      p.line(cx - delta, cy - delta, cx + delta, cy + delta);
      p.line(cx - delta, cy + delta, cx + delta, cy - delta);
    }
    eff.life -= 1;
    if(eff.life > 0) next.push(eff);
  }
  visualEffects = next;
}
function scoreBreakdownText(){
  return `生存${scoreState.base} / 多様性${scoreState.bioBonus} / 安定${scoreState.stability}`;
}
function buildScoreShareText(){
  const counts = getCounts();
  const lines = [
    'Bio-Sphere Manager スコア共有',
    `seed: ${currentSeed}`,
    `ステップ: ${step}`,
    `スコア: ${scoreState.total} (${scoreBreakdownText()})`,
    `終了理由: ${endReason || '進行中'}`,
    `個体数: 草${counts.grass} 草食${counts.herb} 肉食${counts.carn}`,
    `種別: ${SPECIES_DEFS.map(sp=>`${sp.nameJP}:${counts.species[sp.id] ?? 0}`).join(' / ')}`
  ];
  return lines.join('\n');
}
function defaultSpeciesSettings(){
  const s = {};
  for(const sp of SPECIES_DEFS){
    s[sp.id] = {enabled: sp.defaultEnabled !== false, init: sp.defaultInit || 0};
  }
  return s;
}
function updateSpeciesSettingsFromUI(){
  for(const sp of SPECIES_DEFS){
    const chk = el(`chk-${sp.id}`);
    const inp = el(`inInit-${sp.id}`);
    const enabled = chk ? chk.checked : true;
    const init = inp ? clampInt(parseInt(inp.value,10), 0, 5000) : (sp.defaultInit || 0);
    speciesSettings[sp.id] = {enabled, init};
  }
}
function applySpeciesSettingsToUI(settings){
  for(const sp of SPECIES_DEFS){
    const st = settings[sp.id];
    if(!st) continue;
    const chk = el(`chk-${sp.id}`);
    const inp = el(`inInit-${sp.id}`);
    if(chk) chk.checked = !!st.enabled;
    if(inp) inp.value = st.init;
  }
  updateSpeciesSettingsFromUI();
  updateActiveSpeciesLists();
}
function updateActiveSpeciesLists(){
  activeHerbSpecies = SPECIES_DEFS.filter(sp => speciesSettings[sp.id]?.enabled && sp.diet === 'herbivore');
  activeCarnSpecies = SPECIES_DEFS.filter(sp => speciesSettings[sp.id]?.enabled && sp.diet === 'carnivore');
}
function getSpeciesTraits(def){
  const baseGain = def.diet === 'herbivore' ? P.herbGain : P.carnGain;
  const baseRepro = def.diet === 'herbivore' ? P.herbRepro : P.carnRepro;
  const gainDelta = def.gains?.grassDelta ?? def.gains?.herbivoreDelta ?? 0;
  return {
    gain: clampInt(baseGain + gainDelta, 1, 800),
    reproduction: clampInt(baseRepro + (def.reproDelta || 0), 2, 1200),
    metabolism: Math.max(0, def.metabolism ?? P.metabolism),
    maxAge: def.maxAge ?? (def.diet === 'herbivore' ? P.herbMaxAge : P.carnMaxAge),
  };
}
function buildSpeciesControls(){
  const listEl = el('speciesList');
  listEl.innerHTML = '';
  speciesSettings = defaultSpeciesSettings();
  for(const sp of SPECIES_DEFS){
    const row = document.createElement('div');
    row.className = 'species-row';

    const head = document.createElement('div');
    head.className = 'species-head';
    const chk = document.createElement('input');
    chk.type = 'checkbox';
    chk.id = `chk-${sp.id}`;
    chk.checked = speciesSettings[sp.id].enabled;
    chk.addEventListener('change', readParamsFromUI);
    const pill = document.createElement('span');
    pill.className = 'species-pill';
    const shape = document.createElement('span');
    shape.className = `species-shape${sp.shape === 'triangle' ? ' triangle' : ''}`;
    if(sp.shape === 'triangle'){
      shape.style.borderTopColor = speciesColor(sp);
    } else {
      shape.style.background = speciesColor(sp);
    }
    pill.appendChild(shape);
    pill.appendChild(document.createTextNode(sp.diet === 'herbivore' ? '草食' : '肉食'));
    const name = document.createElement('span');
    name.textContent = sp.nameJP;
    head.append(chk, pill, name);

    const desc = document.createElement('div');
    desc.className = 'help';
    desc.id = `desc-${sp.id}`;
    const traits = getSpeciesTraits(sp);
    desc.textContent = `採食/捕食: +${traits.gain} / 代謝: -${traits.metabolism} / 寿命: ${traits.maxAge} / 繁殖閾値: ${traits.reproduction}`;

    const controls = document.createElement('div');
    controls.className = 'species-controls';
    const lbl = document.createElement('label');
    lbl.textContent = '初期個体数';
    lbl.className = 'note';
    const inp = document.createElement('input');
    inp.type = 'number';
    inp.id = `inInit-${sp.id}`;
    inp.min = '0';
    inp.max = '5000';
    inp.value = speciesSettings[sp.id].init;
    inp.addEventListener('change', readParamsFromUI);
    controls.append(lbl, inp);

    row.append(head, desc, controls);
    listEl.appendChild(row);
  }
}
function refreshSpeciesTraitLabels(){
  for(const sp of SPECIES_DEFS){
    const desc = el(`desc-${sp.id}`);
    if(!desc) continue;
    const traits = getSpeciesTraits(sp);
    desc.textContent = `採食/捕食: +${traits.gain} / 代謝: -${traits.metabolism} / 寿命: ${traits.maxAge} / 繁殖閾値: ${traits.reproduction}`;
  }
}
function countAliveFor(list){
  let total = 0;
  for(const sp of list){
    const animalsFor = animals[sp.id] || [];
    for(const a of animalsFor){ if(a.alive) total++; }
  }
  return total;
}
function applyPresetToUI(key){
  const p = PRESETS[key];
  if(!p) return;
  const v = p.values;
  el('inInitGrass').value = v.initGrass;
  el('slGrass').value     = v.grassGrowthRate;
  el('inHerbGain').value  = v.herbGain;
  el('inCarnGain').value  = v.carnGain;
  el('inHerbRepro').value = v.herbRepro;
  el('inCarnRepro').value = v.carnRepro;
  el('inHerbMaxAge').value = v.herbMaxAge;
  el('inCarnMaxAge').value = v.carnMaxAge;
  const climateScale = v.climateIntensity ?? 1;
  const mix = v.terrainMix ?? 0.35;
  const river = clampFloat(0.08 + mix * 0.24, 0, 0.6);
  const rock = clampFloat(0.08 + mix * 0.18, 0, 0.5);
  const forest = clampFloat(0.16 + mix * 0.16, 0, 0.6);
  el('inAvgTemp').value = (18 * climateScale).toFixed(1);
  el('inTempAmp').value = (12 * climateScale).toFixed(1);
  el('inAvgRain').value = Math.round(80 * climateScale);
  el('inRainAmp').value = Math.round(45 * climateScale);
  el('inRiverRatio').value = river.toFixed(2);
  el('inRockRatio').value = rock.toFixed(2);
  el('inForestRatio').value = forest.toFixed(2);
  if(v.plantK) P.plantK = v.plantK;
  const speciesPreset = v.species || {};
  const nextSpeciesSettings = {};
  for(const sp of SPECIES_DEFS){
    const presetCount = speciesPreset[sp.id];
    const baseSetting = speciesSettings[sp.id] || {enabled: sp.defaultEnabled !== false, init: sp.defaultInit || 0};
    const init = presetCount !== undefined ? presetCount : baseSetting.init;
    const enabled = presetCount !== undefined ? presetCount > 0 : baseSetting.enabled;
    nextSpeciesSettings[sp.id] = {enabled, init};
  }
  applySpeciesSettingsToUI(nextSpeciesSettings);
  if(v.endCondition) el('selEndCondition').value = v.endCondition;
  if(v.maxSteps) el('inMaxSteps').value = v.maxSteps;
  if(v.logEvery) el('inLogEvery').value = v.logEvery;
  readParamsFromUI();
  statusMessage = `シナリオ: ${p.label} を適用しました`;
  refreshUI();
}
function applyEnvironmentPreset(key){
  const preset = ENV_PRESETS[key];
  if(!preset) return;
  const v = preset.env;
  el('inRiverRatio').value = v.river;
  el('inRockRatio').value = v.rock;
  el('inForestRatio').value = v.forest;
  el('inAvgTemp').value = v.avgTemp;
  el('inTempAmp').value = v.tempAmp;
  el('inAvgRain').value = v.avgRain;
  el('inRainAmp').value = v.rainAmp;
  el('inPlantScale').value = v.plantScale;
  readParamsFromUI();
  statusMessage = `環境プリセット: ${preset.label} を適用しました`;
  refreshUI();
}
function competitionReproPass(count, k){
  if(!P.competition) return true;
  const prob = clampFloat(1 - (count / Math.max(1, k)), 0, 1);
  return rng() < prob;
}
function competitionExtraCost(count, k){
  if(!P.competition || P.densityCostScale <= 0) return 0;
  return Math.floor((count / Math.max(1, k)) * P.densityCostScale);
}

function deterministicNoise(step, key){
  const h = hash32FromString(`${currentSeed}:${key}:${step}`);
  return (h / 4294967296);
}

function getSeasonName(day){
  const d = day % 365;
  if(d < 80) return '冬';
  if(d < 172) return '春';
  if(d < 264) return '夏';
  return '秋';
}

function getWeatherForStep(step){
  const day = step % 365;
  const seasonalPhase = (2*Math.PI*day)/365;
  const baseTemp = P.avgTemp + P.tempAmp * Math.sin(seasonalPhase - 0.8);
  const baseRain = P.avgRain + P.rainAmp * Math.sin(seasonalPhase + 1.4);
  const noiseLevel = 0.12;
  const tempNoise = (deterministicNoise(step, 'temp') - 0.5) * 6 * noiseLevel;
  const rainNoise = (deterministicNoise(step, 'rain') - 0.5) * 36 * noiseLevel;
  const temperature = baseTemp + tempNoise;
  const rainfall = Math.max(0, baseRain + rainNoise);
  const season = getSeasonName(day);
  return {season, temperature, rainfall};
}

function terrainGrowthMultiplier(t){
  if(t === TERRAIN.ROCK) return 0.25;
  if(t === TERRAIN.RIVER) return 1.45;
  if(t === TERRAIN.FOREST) return 1.15;
  return 1;
}

function terrainMoveCost(t){
  if(t === TERRAIN.ROCK) return 1;
  if(t === TERRAIN.RIVER) return 2;
  if(t === TERRAIN.FOREST) return 0.5;
  return 0;
}
function terrainPassable(t){
  if(t === TERRAIN.RIVER) return false;
  return true;
}

/* ========= 初期化 ========= */
function resetSim(){
  readParamsFromUI();

  currentSeed = getSeedString();
  const seed32 = hash32FromString(currentSeed);
  rng = mulberry32(seed32);
  updateGrassToneMap(currentSeed);
  updateTerrainMap(currentSeed);

  step = 0;
  running = false;
  statusMessage = '停止中';
  hideEndModal();
  biomass.fill(0);
  visualEffects = [];
  stabilitySeries = [];
  scoreState = {total:0, base:0, bioBonus:0, biodiversity:0, stability:0};
  animals = {};
  for(const sp of SPECIES_DEFS){
    animals[sp.id] = [];
  }
  logs = [];
  deathHerbStarve = 0;
  deathCarnStarve = 0;
  deathHerbEaten  = 0;
  deathHerbAge = 0;
  deathCarnAge = 0;
  herbReproAttempts = 0;
  herbReproSuccess = 0;
  carnReproAttempts = 0;
  carnReproSuccess = 0;
  endReason = '';
  peakCounts = {grass:0, herb:0, carn:0};
  weatherState = getWeatherForStep(step);

  // 草をランダム配置（重複を避けて指定数を確保）
  let gPlaced = 0;
  while(gPlaced < P.initGrass && gPlaced < N){
    const idx = Math.floor(rng()*N);
    if(biomass[idx] <= 0){
      biomass[idx] = P.plantK;
      gPlaced++;
    }
  }

  // 草食
  for(const sp of activeHerbSpecies){
    const setting = speciesSettings[sp.id] || {enabled:true, init:0};
    const traits = getSpeciesTraits(sp);
    for(let i=0;i<setting.init;i++){
      const baseEnergy = Math.max(6, Math.floor(traits.reproduction * 0.5));
      animals[sp.id].push({x: randInt(GRID), y: randInt(GRID), energy: baseEnergy + randInt(8), alive:true, age:0, speciesId: sp.id});
    }
  }

  // 肉食
  for(const sp of activeCarnSpecies){
    const setting = speciesSettings[sp.id] || {enabled:true, init:0};
    const traits = getSpeciesTraits(sp);
    for(let i=0;i<setting.init;i++){
      const baseEnergy = Math.max(8, Math.floor(traits.reproduction * 0.4));
      animals[sp.id].push({x: randInt(GRID), y: randInt(GRID), energy: baseEnergy + randInt(10), alive:true, age:0, speciesId: sp.id});
    }
  }

  peakCounts = getCounts();
  resetChart();
  // ログ初回（チャート初期点を残す）
  pushLog();
  refreshUI();
}
function randInt(n){ return Math.floor(rng()*n); }

/* ========= 1ステップ更新 ========= */
function tick(){
  if(endReason) return;
  step++;

  weatherState = getWeatherForStep(step);

  if(step >= P.maxSteps){
    applyEndCondition('最大ステップ到達');
    return;
  }

  // 1) 草の成長：季節と降水・地形で成長率変動（ロジスティック増殖）
  const tempComfort = Math.max(8, P.tempAmp * 1.2 + 10);
  const tempSuit = clampFloat(1 - Math.abs(weatherState.temperature - P.avgTemp) / tempComfort, 0, 1.6);
  const rainSuit = clampFloat(weatherState.rainfall / Math.max(30, P.avgRain), 0, 1.8);
  const growthClimate = clampFloat((tempSuit * 0.55) + (rainSuit * 0.45), 0, 1.8);
  for(let i=0;i<N;i++){
    const terrainMult = terrainGrowthMultiplier(terrain[i]);
    const g = P.grassGrowthRate * terrainMult * growthClimate * P.plantGrowthScale;
    if(g > 0){
      const carrying = P.plantK;
      const growth = g * (1 - (biomass[i] / carrying)) * carrying;
      biomass[i] = clampFloat(biomass[i] + growth, 0, carrying);
    }
    if(rainSuit < 0.5){
      biomass[i] = clampFloat(biomass[i] - (0.12 * (0.5 - rainSuit)), 0, P.plantK);
    }
  }

  let herbAliveCount = countAliveFor(activeHerbSpecies);
  let carnAliveCount = countAliveFor(activeCarnSpecies);

  // 2) 草食の行動：移動→採食→代謝→繁殖
  for(const sp of activeHerbSpecies){
    const traits = getSpeciesTraits(sp);
    const list = animals[sp.id] || [];
    for(const h of list){
      if(!h.alive) continue;

      h.age += 1;
      if(h.age >= traits.maxAge){
        h.alive = false;
        herbAliveCount--;
        deathHerbAge++;
        spawnEffect('death', h.x, h.y);
        continue;
      }

      const moveCost = moveTerrainAware(h);

      const idx = h.y * GRID + h.x;
      if(biomass[idx] > 0){
        const eat = Math.min(biomass[idx], traits.gain);
        biomass[idx] -= eat;
        h.energy += eat;
      }

      const herbExtraCost = competitionExtraCost(herbAliveCount, P.herbK);
      const weatherCost = Math.max(0, Math.abs(weatherState.temperature - P.avgTemp) * 0.05);
      h.energy -= (traits.metabolism + herbExtraCost + moveCost + weatherCost);
      if(h.energy <= 0){
        h.alive = false;
        herbAliveCount--;
        deathHerbStarve++;
        spawnEffect('death', h.x, h.y);
        continue;
      }

      if(h.energy >= traits.reproduction){
        herbReproAttempts++;
        if(competitionReproPass(herbAliveCount, P.herbK)){
          herbReproSuccess++;
          const childEnergy = Math.floor(h.energy / 2);
          h.energy = h.energy - childEnergy;
          list.push({x:h.x, y:h.y, energy: childEnergy, alive:true, age:0, speciesId: sp.id});
          herbAliveCount++;
        }
      }
    }
  }

  // 3) 草食のセル配置（肉食が捕食するため）
  for(let i=0;i<N;i++) herbivoreAt[i].length = 0;
  for(const sp of activeHerbSpecies){
    const list = animals[sp.id] || [];
    for(let i=0;i<list.length;i++){
      const h = list[i];
      if(!h.alive) continue;
      herbivoreAt[h.y * GRID + h.x].push({sid: sp.id, idx: i});
    }
  }

  // 4) 肉食の行動：移動→捕食→代謝→繁殖
  for(const sp of activeCarnSpecies){
    const traits = getSpeciesTraits(sp);
    const list = animals[sp.id] || [];
    for(const c of list){
      if(!c.alive) continue;

      c.age += 1;
      if(c.age >= traits.maxAge){
        c.alive = false;
        carnAliveCount--;
        deathCarnAge++;
        spawnEffect('death', c.x, c.y);
        continue;
      }

      const moveCost = moveTerrainAware(c);

      const idx = c.y * GRID + c.x;
      const cellList = herbivoreAt[idx];
      if(cellList.length > 0){
        const preyRef = cellList.pop();
        if(preyRef){
          const preyList = animals[preyRef.sid];
          const prey = preyList && preyList[preyRef.idx];
          if(prey && prey.alive){
            prey.alive = false;
            deathHerbEaten++;
            c.energy += traits.gain;
            herbAliveCount--;
            spawnEffect('predation', c.x, c.y);
          }
        }
      }

      const carnExtraCost = competitionExtraCost(carnAliveCount, P.carnK);
      const weatherCost = Math.max(0, Math.abs(weatherState.temperature - P.avgTemp) * 0.04);
      if(cellList.length === 0){
        c.energy -= (traits.metabolism + carnExtraCost + moveCost + weatherCost);
      } else {
        c.energy -= (carnExtraCost + moveCost + weatherCost);
      }
      if(c.energy <= 0){
        c.alive = false;
        carnAliveCount--;
        deathCarnStarve++;
        spawnEffect('death', c.x, c.y);
        continue;
      }

      if(c.energy >= traits.reproduction){
        carnReproAttempts++;
        if(competitionReproPass(carnAliveCount, P.carnK)){
          carnReproSuccess++;
          const childEnergy = Math.floor(c.energy / 2);
          c.energy = c.energy - childEnergy;
          list.push({x:c.x, y:c.y, energy: childEnergy, alive:true, age:0, speciesId: sp.id});
          carnAliveCount++;
        }
      }
    }
  }

  // 5) 死体除去（配列を軽く保つ）
  if(step % 10 === 0){
    for(const sp of SPECIES_DEFS){
      if(animals[sp.id]) animals[sp.id] = animals[sp.id].filter(a=>a.alive);
    }
  }

  // 6) ログ
  if(step % logEvery === 0) pushLog();

  // 7) 終了チェック
  const counts = getCounts();
  peakCounts.grass = Math.max(peakCounts.grass, counts.grass);
  peakCounts.herb = Math.max(peakCounts.herb, counts.herb);
  peakCounts.carn = Math.max(peakCounts.carn, counts.carn);
  checkEndConditions(counts);
}

function checkEndConditions(counts){
  if(endReason) return;
  const herbRequired = activeHerbSpecies.length > 0;
  const carnRequired = activeCarnSpecies.length > 0;
  if(P.endCondition === 'anyExtinct'){
    if(counts.grass === 0){
      applyEndCondition('草が絶滅');
      return;
    }
    if(herbRequired && counts.herb === 0){
      applyEndCondition('草食が絶滅');
      return;
    }
    if(carnRequired && counts.carn === 0){
      applyEndCondition('肉食が絶滅');
      return;
    }
  } else if(P.endCondition === 'animalExtinct'){
    if(herbRequired && counts.herb === 0){
      applyEndCondition('草食が絶滅');
      return;
    }
    if(carnRequired && counts.carn === 0){
      applyEndCondition('肉食が絶滅');
      return;
    }
  } else if(P.endCondition === 'totalExtinct'){
    if(counts.grass === 0 && counts.herb === 0 && counts.carn === 0){
      applyEndCondition('全生物が絶滅');
      return;
    }
  }
  if(step >= P.maxSteps){
    applyEndCondition('最大ステップ到達');
  }
}

function applyEndCondition(reason){
  endReason = reason;
  running = false;
  statusMessage = `終了：${reason}`;
  el('btnStart').textContent = '開始';
  pushLog();
  refreshUI();
  const counts = getCounts();
  showEndModal(counts);
}

function showEndModal(counts){
  updateScore(counts, false);
  el('modalReason').textContent = endReason || '-';
  el('modalSteps').textContent = String(step);
  el('modalCounts').textContent = `草${counts.grass} / 草食${counts.herb} / 肉食${counts.carn}`;
  el('modalDeaths').textContent = `草食:飢餓${deathHerbStarve} 捕食${deathHerbEaten} 老衰${deathHerbAge} / 肉食:飢餓${deathCarnStarve} 老衰${deathCarnAge}`;
  el('modalScore').textContent = `${scoreState.total}`;
  el('modalScoreDetail').textContent = scoreBreakdownText();
  el('endModal').style.display = 'flex';
}
function hideEndModal(){
  el('endModal').style.display = 'none';
}

function moveTerrainAware(a){
  // トーラス（端で折り返し）にして境界の癖を減らす
  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
  const start = Math.floor(rng()*4);
  let appliedCost = terrainMoveCost(terrain[a.y * GRID + a.x]);
  for(let i=0;i<4;i++){
    const d = dirs[(start + i) % 4];
    const nx = (a.x + d[0] + GRID) % GRID;
    const ny = (a.y + d[1] + GRID) % GRID;
    const t = terrain[ny * GRID + nx];
    if(terrainPassable(t)){
      a.x = nx; a.y = ny; appliedCost = terrainMoveCost(t); break;
    }
  }
  return appliedCost;
}

function getCounts(){
  let totalBiomass = 0;
  for(let i=0;i<N;i++) totalBiomass += biomass[i];
  let hCount = 0;
  let cCount = 0;
  const species = {};
  for(const sp of SPECIES_DEFS){
    let sCount = 0;
    const list = animals[sp.id] || [];
    for(const a of list){ if(a.alive) sCount++; }
    species[sp.id] = sCount;
    if(sp.diet === 'herbivore') hCount += sCount; else cCount += sCount;
  }
  return {grass: Math.round(totalBiomass), biomassTotal: totalBiomass, herb:hCount, carn:cCount, species};
}

function pushLog(){
  const counts = getCounts();
  updateScore(counts, true);
  const herbRate = herbReproAttempts > 0 ? herbReproSuccess / herbReproAttempts : '';
  const carnRate = carnReproAttempts > 0 ? carnReproSuccess / carnReproAttempts : '';
  logs.push({
    schema_version: SCHEMA_VERSION,
    seed: currentSeed,
    step,
    grass: counts.grass,
    herb: counts.herb,
    carn: counts.carn,
    death_herb_starve: deathHerbStarve,
    death_herb_eaten: deathHerbEaten,
    death_carn_starve: deathCarnStarve,
    death_herb_age: deathHerbAge,
    death_carn_age: deathCarnAge,
    herb_K: P.herbK,
    carn_K: P.carnK,
    competition_enabled: P.competition ? 1 : 0,
    herb_repro_success_rate: herbRate,
    carn_repro_success_rate: carnRate,
    biomass_total: counts.biomassTotal.toFixed(2),
    temperature: weatherState.temperature.toFixed(2),
    rainfall: weatherState.rainfall.toFixed(2),
    season_name: weatherState.season,
    species_counts: counts.species,
  });
  pushChartPoint(step, counts.grass, counts.herb, counts.carn);
  herbReproAttempts = 0;
  herbReproSuccess = 0;
  carnReproAttempts = 0;
  carnReproSuccess = 0;
}
function updateScore(counts, recordSample){
  if(recordSample){
    const signal = counts.herb + counts.carn + counts.grass * 0.02;
    stabilitySeries.push(signal);
    if(stabilitySeries.length > MAX_STABILITY_SAMPLES) stabilitySeries.shift();
  }
  const biodiversity = Object.values(counts.species).filter(v=>v>0).length;
  const base = step;
  const bioBonus = biodiversity * SCORE_BIO_BONUS;
  let stability = SCORE_STABILITY_BASE;
  if(stabilitySeries.length > 1){
    const mean = stabilitySeries.reduce((a,b)=>a+b,0) / stabilitySeries.length;
    const variance = stabilitySeries.reduce((a,b)=>a+Math.pow(b-mean,2),0) / stabilitySeries.length;
    stability = Math.max(0, SCORE_STABILITY_BASE - variance * 0.1);
  }
  scoreState = {total: Math.round(base + bioBonus + stability), base, bioBonus, biodiversity, stability: Math.round(stability)};
}

function refreshUI(){
  const counts = getCounts();
  updateScore(counts, false);
  el('outStep').textContent = String(step);
  el('outSeed').textContent = currentSeed;
  el('outGrass').textContent = String(counts.grass);
  el('outHerb').textContent  = String(counts.herb);
  el('outCarn').textContent  = String(counts.carn);
  el('outSeason').textContent = weatherState.season;
  el('outTemp').textContent = `${weatherState.temperature.toFixed(1)}℃`;
  el('outRain').textContent = `${weatherState.rainfall.toFixed(1)} mm`;
  const scenarioStatus = statusMessage.startsWith('シナリオ:');
  if(running){
    statusMessage = '実行中';
  } else if(!endReason && !scenarioStatus) {
    statusMessage = '停止中';
  }
  const statusEl = el('outStatus');
  statusEl.textContent = statusMessage;
  if(endReason){
    statusEl.style.background = '#402030';
    statusEl.style.borderColor = '#6e3b52';
  } else if(running){
    statusEl.style.background = '#1f3c5d';
    statusEl.style.borderColor = '#2d5f87';
  } else {
    statusEl.style.background = '#132235';
    statusEl.style.borderColor = '#2a3a52';
  }
  el('outEndReason').textContent = endReason || '-';
  el('outTotalStep').textContent = String(step);
  el('outFinalCounts').textContent = `草${counts.grass} / 草食${counts.herb} / 肉食${counts.carn}`;
  el('outPeakCounts').textContent = `草${peakCounts.grass} / 草食${peakCounts.herb} / 肉食${peakCounts.carn}`;
  el('outDeaths').textContent = `草食:飢餓${deathHerbStarve} 捕食${deathHerbEaten} 老衰${deathHerbAge} / 肉食:飢餓${deathCarnStarve} 老衰${deathCarnAge}`;
  el('outScore').textContent = String(scoreState.total);
  el('outScoreDetail').textContent = scoreBreakdownText();
}

/* ========= Chart.js ========= */
let chart = null;
function resetChart(){
  const ctx = el('chart').getContext('2d');
  if(chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        {label:'草', data:[], tension:0.2, borderColor:'#3daa65', backgroundColor:'rgba(61,170,101,0.20)'},
        {label:'草食',  data:[], tension:0.2, borderColor:'#5aa2f7', backgroundColor:'rgba(90,162,247,0.20)'},
        {label:'肉食',  data:[], tension:0.2, borderColor:'#e45a5a', backgroundColor:'rgba(228,90,90,0.20)'},
      ]
    },
    options: {
      responsive:true,
      animation:false,
      scales: {
        x: { ticks:{maxTicksLimit:10} },
        y: { beginAtZero:true }
      },
      plugins: {
        legend: { labels:{ color:'#c9d6e2' } }
      }
    }
  });
}
function pushChartPoint(step, g, h, c){
  if(!chart) return;
  // グラフは重くしないため、ログ間隔でのみ更新（logsと同じタイミング）
  chart.data.labels.push(step);
  chart.data.datasets[0].data.push(g);
  chart.data.datasets[1].data.push(h);
  chart.data.datasets[2].data.push(c);

  const maxPoints = 300;
  if(chart.data.labels.length > maxPoints){
    chart.data.labels.shift();
    for(const ds of chart.data.datasets) ds.data.shift();
  }
  chart.update('none');
}

/* ========= CSV出力 ========= */
function downloadCSV(){
  if(logs.length === 0) return;

  const header = [
    "schema_version","seed","step",
    "grass_count","herbivore_count","carnivore_count",
    "death_herbivore_starve","death_herbivore_eaten","death_carnivore_starve","death_herbivore_age","death_carnivore_age",
    "herb_K","carn_K","competition_enabled","herb_repro_success_rate","carn_repro_success_rate",
    "biomass_total","temperature","rainfall","season_name",
    ...SPECIES_DEFS.map(sp=>`${sp.id}_count`)
  ].join(",");

  const rows = logs.map(r => [
    r.schema_version, JSON.stringify(r.seed), r.step,
    r.grass, r.herb, r.carn,
    r.death_herb_starve, r.death_herb_eaten, r.death_carn_starve, r.death_herb_age, r.death_carn_age,
    r.herb_K, r.carn_K, r.competition_enabled, r.herb_repro_success_rate, r.carn_repro_success_rate,
    r.biomass_total, r.temperature, r.rainfall, r.season_name,
    ...SPECIES_DEFS.map(sp=> r.species_counts ? r.species_counts[sp.id] : '')
  ].join(","));

  const csv = [header, ...rows].join("\n");
  const blob = new Blob([csv], {type:"text/csv;charset=utf-8"});
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const name = `simulation_log_${ts}.csv`;

  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  document.body.appendChild(a);
  a.click();
  a.remove();
}

function buildResultText(){
  const counts = getCounts();
  const lines = [
    `終了理由: ${endReason || '未終了'}`,
    `総ステップ: ${step}`,
    `最終個体数: 草${counts.grass} / 草食${counts.herb} / 肉食${counts.carn}`,
    `最大個体数: 草${peakCounts.grass} / 草食${peakCounts.herb} / 肉食${peakCounts.carn}`,
    `死亡内訳: 草食(飢餓${deathHerbStarve} 捕食${deathHerbEaten} 老衰${deathHerbAge}) / 肉食(飢餓${deathCarnStarve} 老衰${deathCarnAge})`,
    `スコア: ${scoreState.total} (${scoreBreakdownText()})`,
    `種別カウント: ${SPECIES_DEFS.map(sp=>`${sp.nameJP}:${counts.species[sp.id] ?? 0}`).join(' / ')}`
  ];
  return lines.join('\n');
}
function copyResult(){
  const txt = buildResultText();
  navigator.clipboard?.writeText(txt);
}
function copyScoreShare(){
  const txt = buildScoreShareText();
  navigator.clipboard?.writeText(txt);
}

/* ========= p5.js 描画 ========= */
new p5((p)=>{
  p.setup = () => {
    const cnv = p.createCanvas(canvasSize, canvasSize);
    cnv.parent("p5-container");
    p.frameRate(30);
    p5Instance = p;
  };

  p.draw = () => {
    // 速度反映
    readParamsFromUI();

    // 進行
    if(running){
      for(let t=0;t<tickPerFrame;t++) tick();
    }

    // 背景
    p.background(10, 16, 24);

    // 地形 + 草バイオマス（セル塗り：濃淡＋段階表現）
    p.noStroke();
    for(let y=0;y<GRID;y++){
      for(let x=0;x<GRID;x++){
        const idx = y*GRID + x;
        const t = terrain[idx];
        const tone = grassTone[idx] * 0.4;
        const bio = biomass[idx];
        const pat = terrainPattern[idx];

        if(overlayMode === 'terrain'){
          const colorMap = {
            [TERRAIN.GRASSLAND]: [40, 92, 58],
            [TERRAIN.ROCK]: [110, 116, 124],
            [TERRAIN.RIVER]: [40, 122, 180],
            [TERRAIN.FOREST]: [30, 96, 66],
          };
          const base = colorMap[t] || [44, 84, 62];
          p.fill(base[0], base[1], base[2]);
          p.rect(x*cellSize, y*cellSize, cellSize, cellSize);
          drawTerrainPattern(p, x, y, t, pat);
        } else if(overlayMode === 'plant'){
          const ratio = clampFloat(bio / Math.max(1, P.plantK), 0, 1.2);
          const r = 30 + ratio * 50;
          const g = 70 + ratio * 150;
          const b = 40 + ratio * 60;
          p.fill(r, g, b, 220);
          p.rect(x*cellSize, y*cellSize, cellSize, cellSize);
        } else if(overlayMode === 'temp'){
          const tNorm = clampFloat((weatherState.temperature + 5) / 40, 0, 1);
          const r = 40 + 200 * tNorm;
          const g = 80 + 80 * Math.cos(Math.PI * tNorm);
          const b = 200 - 180 * tNorm;
          p.fill(r, g, b, 210);
          p.rect(x*cellSize, y*cellSize, cellSize, cellSize);
        } else if(overlayMode === 'rain'){
          const rNorm = clampFloat(weatherState.rainfall / 140, 0, 1.2);
          const r = 40 + 40 * (1 - rNorm);
          const g = 100 + 80 * rNorm;
          const b = 140 + 80 * rNorm;
          p.fill(r, g, b, 210);
          p.rect(x*cellSize, y*cellSize, cellSize, cellSize);
        } else {
          let base = [32, 70, 50];
          if(t === TERRAIN.ROCK) base = [72, 78, 84];
          else if(t === TERRAIN.RIVER) base = [38, 90, 140];
          else if(t === TERRAIN.FOREST) base = [26, 68, 44];
          p.fill(base[0] + tone*0.08, base[1] + tone*0.12, base[2] + tone*0.10);
          p.rect(x*cellSize, y*cellSize, cellSize, cellSize);
          drawTerrainPattern(p, x, y, t, pat);
          if(bio > 0){
            const ratio = clampFloat(bio / P.plantK, 0, 1);
            const r = 40 + tone * 0.15;
            const g = 120 + tone * 0.9;
            const b = 66 + tone * 0.32;
            p.fill(r, g, b, 180);
            p.rect(x*cellSize, y*cellSize, cellSize, cellSize);
            if(ratio > 0.5){
              p.fill(r + 16, g + 10, b + 8, 200);
              p.rect(x*cellSize, y*cellSize, cellSize, cellSize * (0.35 + ratio*0.4));
            }
          }
        }
      }
    }

    // 草食（エネルギーでサイズ変化）
    for(const sp of activeHerbSpecies){
      p.push();
      if(effectsEnabled){
        p.drawingContext.shadowBlur = 12;
        p.drawingContext.shadowColor = `rgba(${sp.color[0]},${sp.color[1]},${sp.color[2]},0.55)`;
      }
      p.stroke(245);
      p.strokeWeight(2.2);
      p.fill(...sp.color);
      const list = animals[sp.id] || [];
      const traits = getSpeciesTraits(sp);
      for(const h of list){
        if(!h.alive) continue;
        const size = getEnergySize(h.energy, cellSize*0.60, traits.reproduction);
        p.circle((h.x+0.5)*cellSize, (h.y+0.5)*cellSize, size);
      }
      p.pop();
    }

    // 肉食（三角形）：輪郭つき
    for(const sp of activeCarnSpecies){
      p.push();
      if(effectsEnabled){
        p.drawingContext.shadowBlur = 12;
        p.drawingContext.shadowColor = `rgba(${sp.color[0]},${sp.color[1]},${sp.color[2]},0.55)`;
      }
      p.stroke(245);
      p.strokeWeight(2.3);
      p.fill(...sp.color);
      const list = animals[sp.id] || [];
      const traits = getSpeciesTraits(sp);
      for(const c of list){
        if(!c.alive) continue;
        const size = getEnergySize(c.energy, cellSize*0.70, traits.reproduction);
        drawTriangle(p, (c.x+0.5)*cellSize, (c.y+0.5)*cellSize, size);
      }
      p.pop();
    }

    p.noStroke();

    // 格子（薄く）
    p.stroke(22, 32, 46);
    p.strokeWeight(1);
    for(let i=0;i<=GRID;i++){
      p.line(i*cellSize, 0, i*cellSize, canvasSize);
      p.line(0, i*cellSize, canvasSize, i*cellSize);
    }

    refreshUI();
  };
});

/* ========= 設定ドロワー ========= */
const drawer = el('settingsDrawer');
const drawerBackdrop = el('drawerBackdrop');
function toggleDrawer(open){
  drawer.classList.toggle('open', open);
  drawerBackdrop.classList.toggle('open', open);
  drawer.setAttribute('aria-hidden', open ? 'false' : 'true');
}
drawerBackdrop.addEventListener('click', ()=>toggleDrawer(false));
window.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') toggleDrawer(false); });

/* ========= ボタン配線 ========= */
el('btnStart').addEventListener('click', ()=>{
  if(endReason){
    resetSim();
  }
  running = !running;
  el('btnStart').textContent = running ? '停止' : '開始';
  refreshUI();
});
el('btnStep').addEventListener('click', ()=>{
  if(!running) tick();
  refreshUI();
});
el('btnReset').addEventListener('click', ()=>{
  el('btnStart').textContent = '開始';
  resetSim();
});
el('btnCSV').addEventListener('click', downloadCSV);
el('btnOpenDrawer').addEventListener('click', ()=>toggleDrawer(true));
const inlineDrawerBtn = el('btnOpenDrawerInline');
if(inlineDrawerBtn) inlineDrawerBtn.addEventListener('click', ()=>toggleDrawer(true));
const forceEndBtn = el('btnForceEnd');
if(forceEndBtn) forceEndBtn.addEventListener('click', ()=>{ if(!endReason) applyEndCondition('強制終了'); });
el('btnCloseDrawer').addEventListener('click', ()=>toggleDrawer(false));
el('btnCopyResult').addEventListener('click', copyResult);
const btnCopyScore = el('btnCopyScore');
if(btnCopyScore) btnCopyScore.addEventListener('click', copyScoreShare);
el('btnModalReset').addEventListener('click', ()=>{ hideEndModal(); el('btnStart').textContent = '開始'; resetSim(); });
el('btnModalCSV').addEventListener('click', downloadCSV);
el('btnModalCopy').addEventListener('click', copyResult);
const btnModalCopyScore = el('btnModalCopyScore');
if(btnModalCopyScore) btnModalCopyScore.addEventListener('click', copyScoreShare);
el('btnApplyScenario').addEventListener('click', ()=>{
  const key = el('selScenario').value;
  if(!key) return;
  applyPresetToUI(key);
  resetSim();
  const preset = PRESETS[key];
  if(preset){
    statusMessage = `シナリオ: ${preset.label} を適用しました`;
  }
  refreshUI();
});

document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.tab-btn').forEach(b=>b.classList.remove('active'));
    document.querySelectorAll('.tab-panel').forEach(p=>p.classList.remove('active'));
    btn.classList.add('active');
    const panel = document.getElementById(btn.dataset.tab);
    if(panel) panel.classList.add('active');
  });
});

// スライダー表示更新（初期）
el('slFPS').addEventListener('input', ()=>{ readParamsFromUI(); });
el('slGrass').addEventListener('input', ()=>{ readParamsFromUI(); });
el('slZoom').addEventListener('input', ()=>{ updateZoomFromUI(); });
el('chkDaily').addEventListener('change', ()=>{ resetSim(); });
el('inSeed').addEventListener('change', ()=>{ resetSim(); });
document.querySelectorAll('.overlay-btn').forEach(btn => {
  btn.addEventListener('click', ()=>{
    document.querySelectorAll('.overlay-btn').forEach(b=>b.classList.remove('active'));
    overlayMode = btn.dataset.mode || 'life';
    btn.classList.add('active');
  });
});
el('btnApplyEnvironment').addEventListener('click', ()=>{
  const key = el('selEnvPreset').value;
  applyEnvironmentPreset(key);
  resetSim();
});
const hudEl = el('hud');
placeHud();
let dragState = null;
hudEl.addEventListener('pointerdown', (e)=>{
  if(e.target.id === 'btnHudToggle') return;
  dragState = {dx: e.clientX - hudOffset.x, dy: e.clientY - hudOffset.y, id: e.pointerId};
  hudEl.classList.add('dragging');
  hudEl.setPointerCapture(e.pointerId);
});
hudEl.addEventListener('pointermove', (e)=>{
  if(!dragState || dragState.id !== e.pointerId) return;
  hudOffset.x = Math.max(6, e.clientX - dragState.dx);
  hudOffset.y = Math.max(6, e.clientY - dragState.dy);
  placeHud();
});
['pointerup','pointercancel'].forEach(ev=>{
  hudEl.addEventListener(ev, (e)=>{
    if(dragState && dragState.id === e.pointerId){
      dragState = null;
      hudEl.classList.remove('dragging');
    }
  });
});
el('btnHudToggle').addEventListener('click', ()=>{
  hudCollapsed = !hudCollapsed;
  hudEl.classList.toggle('collapsed', hudCollapsed);
});
el('selEnvPreset').addEventListener('change', ()=>{
  const key = el('selEnvPreset').value;
  applyEnvironmentPreset(key);
});

// 初期化
buildSpeciesControls();
updateSpeciesSettingsFromUI();
updateActiveSpeciesLists();
readParamsFromUI();
resetSim();
</script>
</body>
</html>
